# v0.2.5: Invoke Object Method `invokespecial` And `invokevirtual`

<br>

---

<br>

**目標**：支援 `invokevirtual` 和 `invokespecial`

**需要實現的指令**：

| 指令 | Opcode | 功能 |
|------|--------|------|
| `invokespecial` | `0xB7` | 呼叫建構子、私有方法、父類方法 |
| `invokevirtual` | `0xB6` | 呼叫實例方法（支援多型） |
| `dup` | `0x59` | 複製棧頂元素（new 後常用） |

<br>

**設計要點**：

`invokevirtual` 的多型查找：

1. 從物件的實際類型開始查找方法
2. 若找不到，往父類查找
3. 這是 Java 多型的核心機制

<br>

測試目標：

```java
public class TestMethod {
    public static void main(String[] args) {
        Counter c = new Counter();
        c.increment();
        c.increment();
        int x = c.getValue();  // x = 2
    }
}

class Counter {
    int value;
    public Counter() { this.value = 0; }
    public void increment() { this.value++; }
    public int getValue() { return this.value; }
}
```

<br>
<br>

### `invokespecial` vs `invokevirtual`


| 指令名稱       | Opcode | 功能描述                                   |
|----------------|--------|--------------------------------------------|
| invokespecial  | 0xB7   | 呼叫建構子 `<init>`、私有方法、`super.xxx()` |
| invokevirtual  | 0xB6   | 呼叫實例方法（動態綁定，支援多型）          |

<br>

**`invokespecial`: 靜態綁定 (編譯時決定)**

根據 MethodRef 指定的類別查找方法，用於：

* 建構子 <init>
* 私有方法 (private)
* 父類方法 (super.xxx())

<br>

**`invokevirtual`: 動態綁定 (執行時決定)**

根據物件的實際類型查找方法，這就是多型的實現原理。

```java
    ...
    Animal a = new Dog();
    a.speak();  // 呼叫 Dog.speak()，不是 Animal.speak()
```

<br>

**建構子呼叫流程**

```java
Counter c = new Counter();
```

編譯：

```go
new                 // 1. 建立 Counter 物件，推入參考
dup                 // 2. 複製參考（一份給建構子，一份存變數）
invokespecial       // 3. 呼叫 Counter.<init>()
astore_1            // 4. 存入 locals[1]
```

<br>

執行時的棧變化：

```
                 new          dup             invokespecial    astore_1
                  ↓            ↓                  ↓               ↓
Stack:  []  →  [ref]  →  [ref,ref]  →  [ref]  →  []
                                         ↑
                                    建構子消耗一個
                                    初始化物件欄位
```

<br>

**多型的實現原理**

```java
class Animal {
    void speak() { System.out.println("..."); }
}

class Dog extends Animal {
    void speak() { System.out.println("Woof!"); }
}

// 執行時
Animal a = new Dog();
a.speak();  // invokevirtual
```

`invokevirtual` 的查找過程：

1. 從操作數棧取得 objectRef
2. 取得物件的實際類型：obj.Class() → Dog
3. 從 Dog 開始向上查找 speak() 方法
    - Dog 有 speak()？有！→ 呼叫 Dog.speak()
4. 如果 Dog 沒有，會繼續往 Animal 查找

這就是為什麼輸出 "Woof!" 而不是 "..."

<br>

### 實作 invokespecial 時的發現

```go
    // 2. get methodRef
	methodRef := rtcp.GetConstant(i.Index).(*method_area.MethodRef)

	// 3. resolve target method's lang and method
	method := methodRef.ResolvedMethod()
	targetClass := methodRef.ResolvedClass()

	// 4. check <init> must invoke by invokespecial
	if method.Name() == "<init>" && method.Class() != targetClass {
		panic("java.lang.NoSuchMethodError")
	}
```

我做這這邊時有一個疑問，`methodRef.ResolvedClass()` 不就等於是 `method.Class()` 嗎？

事實上結果其實不一樣：

* `methodRef.ResolvedClass()`: MethodRef 裡面記錄的 "目標類別"，也就是 bytecode 中 invokexxx 指定要呼叫的類別
* `resolvedMethod.Class()`: 實際找到方法後，該方法 "定義在哪個類別"，__可能是目標類別，也可能是它的父類！__

<br>

**具體例子**

```java
class Animal {
   void speak() { }  // 方法定義在 Animal
}

class Dog extends Animal {
   // 沒有 override speak()
}
```

如果 bytecode 是 `invokevirtual Dog.speak()V` 那麼:

* `methodRef.ResolvedClass()`  →  Dog (bytecode 指定的類別)
* `methodRef.Class()`  →  Animal (方法實際定義的類別)

<br>

**為什麼建構子要檢查？**

建構子 <init> 是特殊的，它不能被繼承：

```java
class Animal {
    Animal() { }  // Animal 的建構子
}

class Dog extends Animal {
    // Dog 沒有定義自己的建構子
    // 但編譯器會自動生成:
    // Dog() { super(); }
}
```

如果有人嘗試這樣做（理論上不可能通過編譯，但可能有惡意 bytecode）：

```
invokespecial Dog.<init>()V   // 嘗試呼叫 Dog 的建構子
```

但如果 Dog 沒有定義 `<init>`，`lookupMethod` 會找到 `Animal.<init>`：

* methodRef.ResolvedClass()    →  Dog
* resolvedMethod.Class()       →  Animal  (找到的是 Animal 的)

這是不合法的，不能用 `Dog` 的名義呼叫 `Animal` 的建構子，所以要拋出 NoSuchMethodError。


<br>
<br>
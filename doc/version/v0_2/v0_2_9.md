# v0.2.9：字串支援

<br>

---

<br>

## 目標

實現完整的 `java.lang.String` 支援

1. 正確載入 String constant
2. 建立 `String` 物件
3. 實現字串駐留 (String Interning)
4. 支援 `System.out.println(String)`

<br>

## 原理介紹

### Java String 的本質 — 不只是字串

<br>

**String 是一個普通的 Java 類別**


```java
public final class String implements Serializable, Comparable<String>, CharSequence {
    private final char[] value;  // 存放字元的陣列
    private int hash;            // cache 的 hash code（預設 0）
    
    // ... 
}
```

關鍵

* `final` 類別 → 不能被繼承
* `private final char[] value` → 字串內容不可變 (Immutable)
* `hash` 欄位 → 延遲計算並快取

<br>

**為什麼 String 設計成 Immutable？**

1. 執行緒安全: 多個執行緒可以安全地共享同一個 String 物件 (read only)
2. 字串駐留: 相同內容可以共用同一個物件，節省記憶體
3. Hash Cache: hashCode 只需計算一次
4. 安全性: 字串常用於類別名、檔案路徑，不可變更安全

<br>

**String 在記憶體中的結構**

```
┌─────────────────────────────────────────────────────────────────┐
│                    String Object                                │
├─────────────────────────────────────────────────────────────────┤
│  class ──────────────────────────► java/lang/String (Class)     │
│  fields:                                                        │
│    [0] value ────────────────────► char[] Object                │
│    [1] hash ─────────────────────► int (0 or cached value)      │
└─────────────────────────────────────────────────────────────────┘
                                           │
                                           ▼
                               ┌───────────────────────┐
                               │   char[] Object       │
                               ├───────────────────────┤
                               │  class ──► [C         │
                               │  extra: []uint16{     │
                               │    'H', 'e', 'l',     │
                               │    'l', 'o'           │
                               │  }                    │
                               └───────────────────────┘
```

<br>
<br>

### 字元編碼 — UTF-8 vs UTF-16

這是實現 String 的關鍵

**為什麼要關心編碼？**

* Go 的 string: UTF-8 編碼
* Java 的 char[]: UTF-16 編碼

當 JVM 從 .class 檔案載入字串常量時：

1. .class 檔案中的字串是 Modified UTF-8 格式
2. 需要轉換成 Java 的 UTF-16 格式存入 char[]

<br>

**ASCII、UTF-8、UTF-16 的差異**

```
┌─────────────────────────────────────────────────────────────────┐
│ 字元: "Hello中文"                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ ASCII (僅支援英文):                                               │
│   H=0x48, e=0x65, l=0x6C, l=0x6C, o=0x6F                        │
│   中文？→ 無法表示！                                               │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ UTF-8 (變長編碼，1-4 bytes):                                      │
│   H=0x48      (1 byte)                                          │
│   e=0x65      (1 byte)                                          │
│   l=0x6C      (1 byte)                                          │
│   l=0x6C      (1 byte)                                          │
│   o=0x6F      (1 byte)                                          │
│   中=0xE4B8AD (3 bytes)  ← 中文字需要 3 個 bytes                  │
│   文=0xE69687 (3 bytes)                                         │
│                                                                 │
│   總共: 5 + 3 + 3 = 11 bytes                                     │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ UTF-16 (固定 2 bytes，特殊字元用 4 bytes):                         │
│   H=0x0048    (2 bytes)                                         │
│   e=0x0065    (2 bytes)                                         │
│   l=0x006C    (2 bytes)                                         │
│   l=0x006C    (2 bytes)                                         │
│   o=0x006F    (2 bytes)                                         │
│   中=0x4E2D   (2 bytes)  ← 中文字也是 2 個 bytes                  │
│   文=0x6587   (2 bytes)                                         │
│                                                                 │
│   總共: 7 × 2 = 14 bytes                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

<br>


**為什麼 Java 選擇 UTF-16？**

歷史原因：

1. Java 誕生於 1995 年，當時 Unicode 只有 65536 個字元
2. 用 16-bit (2 bytes) 剛好可以表示所有字元
3. 固定長度的好處：str.charAt(i) 可以 O(1) 存取

後來的問題:

1. Unicode 擴展到超過 65536 個字元（emoji 等）
2. 超過 `U+FFFF` 的字元需要用「代理對」(Surrogate Pair) 表示
3. 一個 emoji 可能佔用 2 個 char (4 bytes)

<br>

**Go 與 Java 的編碼轉換**

```go
// Go string (UTF-8) → Java char[] (UTF-16)
func utf8ToUtf16(s string) []uint16 {
    runes := []rune(s)           // Go 的 rune 是 Unicode code point (int32)
    chars := make([]uint16, len(runes))
    for i, r := range runes {
        chars[i] = uint16(r)     // 簡化版：假設沒有超過 U+FFFF 的字元
    }
    return chars
}

// Java char[] (UTF-16) → Go string (UTF-8)
func utf16ToUtf8(chars []uint16) string {
    runes := make([]rune, len(chars))
    for i, c := range chars {
        runes[i] = rune(c)
    }
    return string(runes)
}
```

<br>

MVP 簡化：我們先不處理 Surrogate Pair（超過 U+FFFF 的字元如 emoji）。

<br>
<br>

### Constant Pool 中的字串 — `CONSTANT_String` vs `CONSTANT_Utf8`

Constant Pool 中有兩個字串的 Tag: `CONSTANT_String` `CONSTANT_Utf8`

**兩種字串常量的差別**

```
┌─────────────────────────────────────────────────────────────────┐
│ CONSTANT_Utf8 (tag = 1)                                         │
├─────────────────────────────────────────────────────────────────┤
│ - 儲存原始的 UTF-8 bytes                                          │
│ - 用於類別名、方法名、描述符等「內部使用」                             │
│ - 不會建立 String 物件                                            │
│                                                                 │
│ 結構：                                                           │
│ ┌────────┬─────────┬─────────────────┐                          │
│ │ tag(1) │length(2)│  bytes(n)       │                          │
│ │   1    │  n      │ UTF-8 編碼資料   │                          │
│ └────────┴─────────┴─────────────────┘                          │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│ CONSTANT_String (tag = 8)                                       │
├─────────────────────────────────────────────────────────────────┤
│ - 代表 Java 程式碼中的字串字面量 "Hello"                            │
│ - 指向一個 CONSTANT_Utf8                                         │
│ - 執行時會建立 String 物件                                         │
│                                                                 │
│ 結構：                                                           │
│ ┌────────┬────────────────┐                                     │
│ │ tag(1) │string_index(2) │ → 指向 constant pool 中的某個         │
│ │   8    │                │   CONSTANT_Utf8                     │
│ └────────┴────────────────┘                                     │
└─────────────────────────────────────────────────────────────────┘
```

<br>

**String 在 Constant Pool 中的引用關係**

```java
public class Hello {
    public static void main(String[] args) {
        String s = "Hello World";
        System.out.println(s);
    }
}
```

Constant Pool 內部:

```
┌───────┬──────────────────────┬────────────────────────────────┐
│ Index │ Tag                  │ 內容                            │
├───────┼──────────────────────┼────────────────────────────────┤
│ #1    │ CONSTANT_Methodref   │ ...                            │
│ #2    │ CONSTANT_String      │ string_index = #15             │
│ ...   │ ...                  │ ...                            │
│ #15   │ CONSTANT_Utf8        │ "Hello World"                  │
└───────┴──────────────────────┴────────────────────────────────┘
          │
          │  CONSTANT_String #2
          │       │
          │       ▼
          │  string_index = #15
          │       │
          │       ▼
          │  CONSTANT_Utf8 #15 = "Hello World"
          ▼
     ldc #2  →  載入 String 物件到 stack
```

<br>

**`ldc` 指令載入字串的流程**

1. 從 RuntimeConstantPool 取得 `#2`
2. 發現是 `string` 類型
3. 取得對應的 Go string 值 `"Hello World"`
4. 呼叫 `InternString("Hello World")`
   * 檢查 String Pool 是否已有此字串
   * 若有 → 返回已存在的 `String` 物件
   * 若無 → 建立新 `String` 物件，加入 Pool，返回
5. 將 `String` 物件引用 `push` 到 op-stack

<br>

### 字串駐留 (String Interning) — JVM 的記憶體優化

**什麼是字串駐留？**

```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = new String("Hello");

System.out.println(s1 == s2);  // true  (同一個物件)
System.out.println(s1 == s3);  // false (不同物件)
System.out.println(s1.equals(s3));  // true (內容相同)
```

**String Pool (字串池)**

```
┌─────────────────────────────────────────────────────────────────┐
│ JVM String Pool                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   s1 ─────────┐                                                 │
│               ▼                                                 │
│         ┌─────────────┐                                         │
│         │ String obj  │  ← Pool 中的唯一 "Hello"                 │
│         │ "Hello"     │                                         │
│         └─────────────┘                                         │
│               ▲                                                 │
│   s2 ─────────┘                                                 │
│                                                                 │
│                                                                 │
│   s3 ─────────► ┌─────────────┐                                 │
│                 │ String obj  │  ← Heap 中的新物件                │
│                 │ "Hello"     │    (不在 Pool 中)                │
│                 └─────────────┘                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

<br>

**為什麼需要字串駐留？**

場景: 大型應用程式中有大量重複字串

* __沒有字串駐留__: "ERROR" 出現 10000 次 → 10000 個 String 物件 → 浪費記憶體
* __有字串駐留__: "ERROR" 出現 10000 次 → 1 個 String 物件 → 節省記憶體

額外好處：

* 字串比較可以用 == 而不是 equals()（更快，比較兩個 ref 而已，前提是都來自 Pool）

<br>

**哪些字串會被駐留？**

自動駐留的字串:

1. 字串字面量: `String s = "Hello";`
2. 編譯期常量運算: `String s = "Hel" + "lo";`
3. 類別名、方法名等 JVM 內部字串

不會自動駐留的字串:

1. `new String("Hello")`
2. 執行時字串串接：`String s = s1 + s2;`
3. `substring()` 等方法的返回值

手動駐留:

* 使用 `intern()` 會將字串加入 Pool 並返回 Pool 中的引用:
`String s = new String("Hello").intern();`

<br>

**String Pool 的位置演變**

Java 6 及之前:
* String Pool 在 PermGen (永久代)
* 問題：PermGen 大小固定，容易 OOM

Java 7 開始:                                                 
* String Pool 移到 Heap                                         
* 好處：可以被 GC 回收，更靈活                                 
                                                                
Java 8:                                                     
* PermGen 被 Metaspace 取代                                     
* String Pool 仍在 Heap

<br>

---

<br>

## MVP 階段的設計決策

```
┌─────────────────────────────────────────────────────────────────┐
│ v0.2.9 實現清單                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ 1. String Pool (字串池)                                          │
│    └─ runtime/heap/string_pool.go                               │
│                                                                 │
│ 2. String 物件建立                                               │
│    └─ 建立帶有 value (char[]) 的 String 物件                      │
│                                                                 │
│ 3. 編碼轉換工具                                                   │
│    ├─ Go string (UTF-8) → Java char[] (UTF-16)                 │
│    └─ Java char[] (UTF-16) → Go string (UTF-8)                 │
│                                                                 │
│ 4. 修改 ldc 指令                                                 │
│    └─ 從常量池載入字串時，使用 String Pool                          │
│                                                                 │
│ 5. 修改 RuntimeConstantPool                                     │
│    └─ 處理 CONSTANT_String 類型                                  │
│                                                                 │
│ 6. 擴展 println Native 方法                                      │
│    └─ 支援 println(Ljava/lang/String;)V                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

<br>

### 實現取捨

完整模擬 java.lang.String 類別需要依賴 rt.jar，處理大量依賴。

這裡採用 HACK 方式實現

```go
// 不載入真正的 java.lang.String 類別
// 直接建立一個「模擬」的 String 物件
func NewJString(loader *ClassLoader, goStr string) *Object {
    // 1. 將 Go string 轉成 UTF-16 char[]
    chars := utf8ToUtf16(goStr)
    
    // 2. 建立 char[] 陣列物件
    charArr := NewCharArray(nil, int32(len(chars)))
    charArr.SetChars(chars)
    
    // 3. 建立 String 物件（暫時用特殊方式）
    strObj := &Object{}
    strObj.SetExtra(charArr)  // 把 char[] 存在 extra 欄位
    
    return strObj
}

// 從 String 物件取得 Go string
func GoString(strObj *Object) string {
   // 1. 取得 char[] 陣列
   charArr := strObj.Extra().(*Object)
   
   // 2. 取得 []uint16 資料
   chars := charArr.Chars()
   
   // 3. 轉換回 Go string (UTF-8)
   return utf16ToUtf8(chars)
}
```


### LDC

修改後的 ldc 實現

```go
func (l *LDC) Execute(frame *runtime.Frame) {
    rtcp := frame.Method().Class().ConstantPool()
    c := rtcp.GetConstant(l.Index)
    stack := frame.OperandStack()

    switch val := c.(type) {
    case int32:
        stack.PushInt(val)
    case float32:
        stack.PushFloat(val)
    case string:
        // 建立真正的 String 物件
        loader := frame.Method().Class().Loader()
        stringObj := heap.InternString(loader, val)
        stack.PushRef(stringObj)
    case *method_area.ClassRef:
        // TODO: 載入 Class 物件 (v0.3.0 反射支援)
        panic("ldc with Class not yet supported")
    default:
        panic("unknown constant type")
    }
}
```

<br>

### `println(String)` 的實現

```go
// printlnString - print String object
// Java: System.out.println("Hello");
// Descriptor: (Ljava/lang/String;)V
//
// LocalVars:
//   [0] = this (PrintStream ref)
//   [1] = String object ref
func printlnString(frame *runtime.Frame) {
    // 1. 取得 String 物件引用
    strRef := frame.LocalVars().GetRef(1)
    
    if strRef == nil {
        fmt.Println("null")
        return
    }
    
    // 2. 從 String 物件取得 Go string
    strObj := strRef.(*heap.Object)
    goStr := heap.GoString(strObj)
    
    // 3. 輸出
    fmt.Println(goStr)
}
```

<br>
<br>

## 測試案例

### 基本列印 String

```java
public class TestString {
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "World";
        System.out.println(s1);       // 輸出: Hello
        System.out.println(s2);       // 輸出: World
        System.out.println("Done");   // 輸出: Done
    }
}
```

<br>

### 中文測試

```java
public class TestChineseString {
    public static void main(String[] args) {
        String s = "你好世界";
        System.out.println(s);  // 輸出: 你好世界
    }
}
```

<br>


### String Pool 測試

```java
public class TestStringCompare {
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "Hello";
        
        if (s1 == s2) {
            System.out.println(1);  // 應該輸出 1
        } else {
            System.out.println(0);  // 不應該到這裡
        }
        
        System.out.println(999);
    }
}
```

<br>
<br>

---

### 修改摘要

1. string_pool.go (新增)

* `utf8ToUtf16()` / `utf16ToUtf8()` — 編碼轉換
* `NewJString()` — 建立 Java String 物件
* `GoString()` — 從 String 物件取得 Go string
* `InternString()` — 字串駐留核心函數
* `IsJString()` — 檢查是否為 String 物件

2. ldc.go (修改)

* case string: 改為呼叫 `heap.InternString(val)`
* 不再使用舊的 `internString()` 函數

3. print_stream.go (修改)

* 新增 `printlnString()` 函數
* 在 native method `init()` 中註冊 `(Ljava/lang/String;)V`
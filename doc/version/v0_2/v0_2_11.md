# v0.2.11：介面支援

<br>

---

<br>

**目標**：支援 Java 介面的定義與調用

**需要實現的指令**：

| 指令 | Opcode | 功能 |
|------|--------|------|
| `invokeinterface` | `0xB9` | 調用介面方法 |

<br>

**設計要點**：

`invokeinterface` vs `invokevirtual` 的差異：

```
invokevirtual:
  - 用於調用類的實例方法
  - 可以利用 vtable（方法在固定偏移量）優化

invokeinterface:
  - 用於調用介面方法
  - 無法使用 vtable（因為類可以實現多個介面）
  - 需要在運行時搜索方法
```

<br>

**介面方法查找流程**：

```
invokeinterface Runnable.run()V
    │
    ├─ 1. 從棧取得 objectref
    ├─ 2. 取得 objectref 的實際類型 C
    ├─ 3. 在 C 中查找 run()V
    │     ├─ C 有此方法？→ 調用
    │     └─ C 沒有？→ 往父類查找
    └─ 4. 找不到 → AbstractMethodError
```

<br>

**invokeinterface 的特殊格式**：

```
invokeinterface 的操作數比較特殊：
┌──────────────────────────────────────────────┐
│ invokeinterface indexbyte1 indexbyte2 count 0│
│               (2 bytes)            (1) (1)   │
└──────────────────────────────────────────────┘

count: 參數佔用的 slot 數 + 1（包含 this）
最後一個 0: 歷史遺留，必須為 0
```

<br>

**需要完善的模組**：

```go
// runtime/method_area/class.go

// 標記類是否為介面
func (c *Class) IsInterface() bool {
    return c.accessFlags & ACC_INTERFACE != 0
}

// 取得類實現的所有介面
func (c *Class) Interfaces() []*Class

// 在類及其父類中查找介面方法的實現
func (c *Class) LookupInterfaceMethod(name, descriptor string) *Method
```

<br>

**測試目標**：

```java
interface Greeting {
    void sayHello();
}

class EnglishGreeting implements Greeting {
    public void sayHello() {
        System.out.println(1);  // 代表 "Hello"
    }
}

class ChineseGreeting implements Greeting {
    public void sayHello() {
        System.out.println(2);  // 代表 "你好"
    }
}

public class TestInterface {
    public static void main(String[] args) {
        Greeting g1 = new EnglishGreeting();
        Greeting g2 = new ChineseGreeting();
        
        g1.sayHello();  // invokeinterface → 輸出 1
        g2.sayHello();  // invokeinterface → 輸出 2
    }
}
```

<br>
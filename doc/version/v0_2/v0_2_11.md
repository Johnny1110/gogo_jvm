# v0.2.11：介面支援 (Interface Support)

<br>

---

<br>

**目標**：實現 Java 介面的定義與調用機制

1. 理解 Java 介面在 JVM 層級的表示方式
2. 理解 `invokeinterface` 與 `invokevirtual` 的設計差異
3. 實現 `invokeinterface` 指令 (`0xB9`)
4. 完善 `InterfaceMethodRef` 的解析邏輯
5. 實現介面方法的動態查找機制

<br>
<br>

## 原理介紹

### Java 介面機制的本質 — 多重繼承的替代方案

<br>

Java 設計者選擇了 單繼承 + 多介面實現 的模型，這是一個深思熟慮的設計決策：


C++ 的多重繼承問題 (鑽石問題): 
```
          ┌─────────┐
          │    A    │
          │ void f()│
          └────┬────┘
         ┌─────┴─────┐
         ▼           ▼
    ┌─────────┐ ┌─────────┐
    │    B    │ │    C    │
    │ void f()│ │ void f()│
    └────┬────┘ └────┬────┘
         └─────┬─────┘
               ▼
          ┌─────────┐
          │    D    │   ← D.f() 該呼叫誰的？B.f()? C.f()? A.f()?
          └─────────┘
```

<br>

Java 的解決方案：
```
    ┌─────────────┐     ┌─────────────┐
    │ Interface A │     │ Interface B │
    │  void f();  │     │  void g();  │
    └──────┬──────┘     └──────┬──────┘
           │                   │
           └─────────┬─────────┘
                     ▼
              ┌─────────────┐
              │   Class C   │  ← C 必須實現 f() 和 g()
              │  void f(){} │     不存在歧義！
              │  void g(){} │
              └─────────────┘
```

<br>

### 為什麼介面解決了鑽石問題？

1. 介面只有方法簽名，沒有實現 (Java 8 之前)
2. 實現類必須提供所有方法的實現
3. 呼叫時永遠是呼叫實現類的方法，不存在 "__該呼叫誰__" 的問題

<br>

---

<br>

## 介面在 JVM 中的表示


### 介面也是一種 Class

在 JVM 層面，介面和類的表示方式幾乎相同，差別在於 access_flags:

| Flag 名稱        | 十六進位值 | 說明                         |
|------------------|------------|------------------------------|
| ACC_PUBLIC       | 0x0001     | 公開類 / 介面                |
| ACC_FINAL        | 0x0010     | 不可繼承（介面不能有）       |
| ACC_SUPER        | 0x0020     | 使用 `invokespecial` 新語義  |
| ACC_INTERFACE    | 0x0200     | ★ 這是介面                  |
| ACC_ABSTRACT     | 0x0400     | 抽象類 / 介面                |

**介面的 access_flags 必須包含: **
- ACC_INTERFACE (0x0200)
- ACC_ABSTRACT  (0x0400)

所以介面的 access_flags 至少是 0x0600



# v0.2.11：介面支援 (Interface Support)

<br>

---

<br>

**目標**：實現 Java 介面的定義與調用機制

1. 理解 Java 介面在 JVM 層級的表示方式
2. 理解 `invokeinterface` 與 `invokevirtual` 的設計差異
3. 實現 `invokeinterface` 指令 (`0xB9`)
4. 完善 `InterfaceMethodRef` 的解析邏輯
5. 實現介面方法的動態查找機制

<br>
<br>

## 原理介紹

### Java 介面機制的本質 — 多重繼承的替代方案

<br>

Java 設計者選擇了 單繼承 + 多介面實現 的模型，這是一個深思熟慮的設計決策：


C++ 的多重繼承問題 (鑽石問題): 
```
          ┌─────────┐
          │    A    │
          │ void f()│
          └────┬────┘
         ┌─────┴─────┐
         ▼           ▼
    ┌─────────┐ ┌─────────┐
    │    B    │ │    C    │
    │ void f()│ │ void f()│
    └────┬────┘ └────┬────┘
         └─────┬─────┘
               ▼
          ┌─────────┐
          │    D    │   ← D.f() 該呼叫誰的？B.f()? C.f()? A.f()?
          └─────────┘
```

<br>

Java 的解決方案：
```
    ┌─────────────┐     ┌─────────────┐
    │ Interface A │     │ Interface B │
    │  void f();  │     │  void g();  │
    └──────┬──────┘     └──────┬──────┘
           │                   │
           └─────────┬─────────┘
                     ▼
              ┌─────────────┐
              │   Class C   │  ← C 必須實現 f() 和 g()
              │  void f(){} │     不存在歧義！
              │  void g(){} │
              └─────────────┘
```

<br>

### 為什麼介面解決了鑽石問題？

1. 介面只有方法簽名，沒有實現 (Java 8 之前)
2. 實現類必須提供所有方法的實現
3. 呼叫時永遠是呼叫實現類的方法，不存在 "__該呼叫誰__" 的問題

<br>

---

<br>

## 介面在 JVM 中的表示

### 介面也是一種 Class

在 JVM 層面，介面和類的表示方式幾乎相同，差別在於 `access_flags`:

| Flag 名稱        | 十六進位值 | 說明                         |
|------------------|------------|------------------------------|
| ACC_PUBLIC       | 0x0001     | 公開類 / 介面                |
| ACC_FINAL        | 0x0010     | 不可繼承（介面不能有）       |
| ACC_SUPER        | 0x0020     | 使用 `invokespecial` 新語義  |
| ACC_INTERFACE    | 0x0200     | ★ 這是介面                  |
| ACC_ABSTRACT     | 0x0400     | 抽象類 / 介面                |

**介面的 access_flags 必須包含:**
- `ACC_INTERFACE` (0x0200)
- `ACC_ABSTRACT`  (0x0400)

所以介面的 access_flags 至少是 `0x0600`

<br>

### 介面的特殊規則

1. 不能被實例化（`new Interface()` 是非法的）
2. 所有方法預設 `public abstract`（Java 8 前）
3. 所有欄位預設 `public static final`
4. 不能有 instance field（只能有 `const`）
5. super_class 必須是 `java/lang/Object`

<br>

### ClassFile 中介面的結構

```java
// Java 源碼
interface Greeting {
    void sayHello();
}
```

編譯後的 ClassFile 結構:

```
ClassFile {
    magic: 0xCAFEBABE
    minor_version: 0
    major_version: 52
    constant_pool_count: ...
    constant_pool: [...]
    access_flags: 0x0601      // ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT
    this_class: #1            // Greeting
    super_class: #2           // java/lang/Object（介面也有父類）
    interfaces_count: 0
    interfaces: []
    fields_count: 0
    fields: []
    methods_count: 1
    methods: [
        {
            access_flags: 0x0401  // ACC_PUBLIC | ACC_ABSTRACT
            name_index: #3        // sayHello
            descriptor_index: #4  // ()V
            attributes_count: 0   // 抽象方法沒有 Code 屬性
        }
    ]
    ...
}
```


<br>

---

<br>

## 四種方法呼叫指令的比較

JVM 有四種方法呼叫指令，理解它們的差異是理解 `invokeinterface` 的關鍵:

| 指令             | Opcode | 綁定時機 | 用途               |
|------------------|--------|----------|------------------|
| `invokestatic`    | `0xB8`   | 編譯時   | 靜態方法             |
| `invokespecial`   | `0xB7`   | 編譯時   | 建構子, 私有方法, super |
| `invokevirtual`    | `0xB6`   | 執行時   | 一般實例方法（類）        |
| `invokeinterface`  | `0xB9`   | 執行時   | 介面方法             |

綁定時機的含義:
* __編譯時綁定__: 方法的地址在編譯/載入時就確定了
* __執行時綁定__: 需要根據物件的實際類型動態查找方法

<br>
<br>

### `invokevirtual` vs `invokeinterface` — 為什麼需要兩個指令？

<br>

**`invokevirtual` 的優化 — vtable（虛方法表）**


單繼承的類可以使用 `vtable` 優化：
```
  Object 的 vtable:          Animal 的 vtable:        Dog 的 vtable:
  ┌─────────────────┐        ┌─────────────────┐      ┌─────────────────┐
  │ 0: hashCode()   │        │ 0: hashCode()   │      │ 0: hashCode()   │
  │ 1: equals()     │        │ 1: equals()     │      │ 1: equals()     │
  │ 2: toString()   │        │ 2: toString()   │      │ 2: toString()   │
  └─────────────────┘        │ 3: speak()      │      │ 3: speak() ─────┼─→ Dog.speak()
                             └─────────────────┘      │ 4: bark()       │
                                                      └─────────────────┘
```

因為是單繼承，`speak()` 在所有子類的 `vtable` 中永遠在位置 __3__。
`invokevirtual` `Animal.speak()` 可以直接用 `vtable[3]` 取得方法，O(1) 時間複雜度。

<br>

**`invokeinterface` 無法使用 vtable 的原因**

一個類可以實現多個介面，同一個方法在不同類的 vtable 中位置不同：

```java
interface Runnable { void run(); }
interface Callable { void run(); }  // 假設也有 run()
```

```
class TaskA implements Runnable {
    vtable:
    ┌─────────────────┐
    │ 0: hashCode()   │
    │ 1: equals()     │
    │ 2: toString()   │
    │ 3: run() ───────┼─→ TaskA.run()    ← run() 在位置 3
    └─────────────────┘
}

class TaskB implements Runnable, Comparable {
    vtable:
    ┌─────────────────┐
    │ 0: hashCode()   │
    │ 1: equals()     │
    │ 2: toString()   │
    │ 3: compareTo()  │
    │ 4: run() ───────┼─→ TaskB.run()    ← run() 在位置 4，不同了！
    └─────────────────┘
}
```

問題: `invokeinterface` `Runnable.run()` 無法確定 `run()` 在 `vtable` 的哪個位置。
解決: __只能在執行時搜索方法。__

<br>
<br>

### HotSpot 的優化 — itable（介面方法表）

現代 JVM 使用 `itable` 來加速 `invokeinterface`:

```
Object Header 擴展：
┌────────────────────────────────────────────────────────────┐
│ Object                                                     │
├────────────────────────────────────────────────────────────┤
│ mark word                                                  │
│ class pointer ──────────────────┐                          │
│ instance fields...              │                          │
└─────────────────────────────────│──────────────────────────┘
                                  ▼
                         ┌─────────────────┐
                         │     Class       │
                         ├─────────────────┤
                         │ vtable          │
                         │ itable ─────────┼───┐
                         └─────────────────┘   │
                                               ▼
                                  ┌────────────────────────┐
                                  │ Interface → offset     │
                                  ├────────────────────────┤
                                  │ Runnable → 3           │
                                  │ Comparable → 4         │
                                  └────────────────────────┘
```

<br>

---

<br>

## `invokeinterface`  指令詳解

### 指令格式

`invokeinterface` 的格式比其他 `invoke` 指令特殊:

```
┌────────┬──────────┬──────────┬───────┬─────┐
│ opcode │indexbyte1│indexbyte2│ count │  0  │
│  0xB9  │    u1    │    u1    │  u1   │ u1  │
└────────┴──────────┴──────────┴───────┴─────┘
          ←──    2 bytes    ──→
```

總共 5 bytes（1 opcode + 4 operands）


**各欄位說明:**
* indexbyte1, indexbyte2: 組成常量池索引，指向 `InterfaceMethodRef`
* count: 參數佔用的 slot 數 + 1（包含 this）
* 最後的 0: 歷史遺留欄位，必須為 0

<br>

### 為什麼 `invokeinterface` 要多兩個 bytes？

歷史原因（早期 JVM 解釋器優化）:

* `count` 欄位:
  * 早期解釋器用它來快速計算需要從棧上彈出多少參數
  * 不需要解析方法描述符
  * 現代 JVM 已經不太需要這個優化了
* `最後的` 0:
  * 預留欄位，原本可能計劃用於其他用途，但最終沒有使用
  * JVM 規範要求它必須為 0
  * JVM 驗證器會檢查這個值，__必須遵守__

<br>

### OpStack 變化情況

執行前：
```
┌─────────────────────────────────────┐
│ ...                                 │
│ objectref (實現介面的物件引用)         │  ← 棧底
│ arg1                                │
│ arg2                                │
│ ...                                 │
│ argN                                │  ← 棧頂
└─────────────────────────────────────┘
```

執行後（假設方法有返回值）：
```
┌─────────────────────────────────────┐
│ ...                                 │
│ return value                        │  ← 棧頂
└─────────────────────────────────────┘
```

執行後（方法返回 void）：
```
┌─────────────────────────────────────┐
│ ...                                 │  ← 棧頂
└─────────────────────────────────────┘
```

<br>
<br>

### `invokeinterface` 執行流程

```
invokeinterface #index, count, 0
    │
    ├─ 1. 從常量池取得 InterfaceMethodRef
    │     └─ 解析得到：介面名稱、方法名、描述符
    │
    ├─ 2. 確認引用的確實是介面（不是類）
    │     └─ 否則拋出 IncompatibleClassChangeError
    │
    ├─ 3. 從操作數棧取得 objectref
    │     └─ objectref 在棧中的位置 = 棧頂 - (count - 1)
    │
    ├─ 4. 空值檢查
    │     └─ objectref == null → 拋出 NullPointerException
    │
    ├─ 5. 取得 objectref 的實際類型 C
    │     └─ C = objectref.getClass()
    │
    ├─ 6. 在 C 中查找方法實現
    │     ├─ 6.1 在 C 的方法中查找
    │     ├─ 6.2 找不到？往 C 的父類查找
    │     ├─ 6.3 還找不到？在 C 實現的介面中查找（Java 8 default method）
    │     └─ 6.4 都找不到 → AbstractMethodError
    │
    ├─ 7. 檢查方法是否為 public
    │     └─ 不是 public → IllegalAccessError
    │
    ├─ 8. 檢查方法是否為 abstract
    │     └─ 是 abstract → AbstractMethodError
    │
    └─ 9. 呼叫方法
          └─ 建立新 Frame，傳遞參數，執行方法
```

<br>

---

<br>

## 介面方法查找演算法

### `invokeinterface` vs `invokevirtual` 的查找差異

`invokevirtual` 的查找（簡單）:

1. 從物件的實際類別開始
2. 在當前類別的方法中查找
3. 找不到就往父類別查找
4. 重複直到找到或到達 Object


`invokeinterface` 的查找（複雜）:

1. 從物件的實際類別開始
2. 在當前類別的方法中查找
3. 找不到就往父類別查找
4. 還找不到，在實現的介面中查找 (Java 8 default method)
5. 遞迴搜索父介面


<br>

### 為什麼要在介面中查找？ — Java 8 Default Method

```
// Java 8 引入的 default method
interface Greeting {
    default void sayHello() {
        System.out.println("Hello!");  // 介面可以有實現了！
    }
}

class SimpleGreeting implements Greeting {
    // 沒有 override sayHello()
    // 會使用介面的 default 實現
}

// 呼叫時：
Greeting g = new SimpleGreeting();
g.sayHello();  // invokeinterface
               // 在 SimpleGreeting 中找不到 sayHello()
               // 需要在 Greeting 介面中找到 default 實現
```

<br>

### 圖解: 多介面情況下的查找

```
interface A { default void foo() { print(1); } }
interface B { default void foo() { print(2); } }
class C implements A, B {
    // 編譯錯誤！必須 override foo() 來解決衝突
}

interface A { default void foo() { print(1); } }
interface B extends A { }  // B 繼承 A 的 foo()
class C implements B {
    // OK，使用 A 的 default foo()
}
```

查找路徑示意圖：

```
                    ┌─────────────┐
                    │  Object     │
                    └──────┬──────┘
                           │
              ┌────────────┴────────────┐
              │                         │
        ┌─────┴─────┐             ┌─────┴─────┐
        │ Interface │             │   Class   │ <- 2. 優先從繼承關係找
        │     A     │             │   Parent  │
        │ foo()     │             │           │
        └─────┬─────┘             └─────┬─────┘
              │                         │
        ┌─────┴─────┐                   │
        │ Interface │                   │
        │     B     │                   │
        └─────┬─────┘                   │
              │                         │
              └───────────┬─────────────┘
                          │
                    ┌─────┴─────┐
                    │  Class C  │  ← 1. 從這裡開始查找
                    │implements │
                    │    B      │
                    └───────────┘

查找順序：C → Parent → Object → B → A
```

<br>

---

<br>

## `RuntimeConstantPool` 中的 `InterfaceMethodRef`

### `InterfaceMethodRef` vs `MethodRef`

**常量池中有兩種方法引用:**

* `CONSTANT_Methodref` (tag = 10)
  * 用於 `invokevirtual`, `invokespecial`, `invokestatic`
  * 引用類的方法


* `CONSTANT_InterfaceMethodref` (tag = 11)
  * 用於 `invokeinterface`
  * 引用介面的方法

<br>

它們的結構完全相同:

```
┌────────────────────────────────────────────┐
│ tag (1 byte)                               │
│ class_index (2 bytes) → CONSTANT_Class     │
│ name_and_type_index (2 bytes) → NameAndType│
└────────────────────────────────────────────┘
```

差別在於: 
* `MethodRef` 的 `class_index` 必須指向類
* `InterfaceMethodRef` 的 `class_index` 必須指向介面

<br>

### 為什麼要區分？

JVM 驗證器需要區分:

1. 類型檢查
    - `MethodRef`: 驗證引用的是類
    - `InterfaceMethodRef`: 驗證引用的是介面

2. 指令匹配
    - `invokevirtual` 必須使用 `MethodRef`
    - `invokeinterface` 必須使用 `InterfaceMethodRef`

3. 優化機會
    - 如果錯誤使用，JVM 可以提前報錯
    - 不需要等到執行時才發現問題

<br>

---

<br>

## 錯誤處理

### `invokeinterface` 可能拋出的錯誤

| 錯誤類型                         | 觸發條件說明                                     |
|----------------------------------|--------------------------------------------------|
| IncompatibleClassChangeError     | InterfaceMethodRef 指向的不是介面               |
| NullPointerException             | objectref 為 null                               |
| AbstractMethodError              | 找到的方法是 abstract（沒有實現）              |
| IllegalAccessError               | 找到的方法不是 public                          |
| NoSuchMethodError                | 完全找不到方法                                 |
| UnsatisfiedLinkError             | 方法是 native 但沒有實作（找不到對應的實作）  |

<br>

### 錯誤檢查的順序

`invokeinterface` 的錯誤檢查順序（按規範）:

```
1. 解析 InterfaceMethodRef
   └─ 失敗 → NoSuchMethodError 或相關連結錯誤

2. 檢查引用的是否為介面
   └─ 不是介面 → IncompatibleClassChangeError

3. 取得 objectref
   └─ 為 null → NullPointerException

4. 在實際類別中查找方法
   └─ 找不到 → AbstractMethodError

5. 檢查方法訪問權限
   └─ 不是 public → IllegalAccessError

6. 檢查方法是否為 abstract
   └─ 是 abstract → AbstractMethodError

7. 執行方法
```


<br>

---

<br>

### 介面與 `instanceof` / `checkcast`

`instanceof` 對介面的處理:

```java
Object obj = new ArrayList();

// 類型檢查
obj instanceof List          // true (ArrayList implements List)
obj instanceof Collection     // true (List extends Collection)
obj instanceof Serializable   // true (ArrayList implements Serializable)
obj instanceof Map            // false
```

`instanceof` 的判斷邏輯（包含介面）:

```
obj instanceof T:

1. 如果 obj 是 null → false

2. 如果 T 是類別：
   └─ 檢查 obj.class 是否為 T 或 T 的子類

3. 如果 T 是介面：
   └─ 檢查 obj.class 是否實現了 T
   └─ 需要遞迴檢查所有實現的介面及其父介面
```

<br>

---

<br>

## Test Case

### 基本介面調用

```java
interface Greeting {
    void sayHello();
}

class EnglishGreeting implements Greeting {
    public void sayHello() {
        System.out.println(1);  // 代表 "Hello"
    }
}

class ChineseGreeting implements Greeting {
    public void sayHello() {
        System.out.println(2);  // 代表 "你好"
    }
}

public class TestInterface {
    public static void main(String[] args) {
        Greeting g1 = new EnglishGreeting();
        Greeting g2 = new ChineseGreeting();
        
        g1.sayHello();  // 輸出 1
        g2.sayHello();  // 輸出 2
    }
}
```

<br>

### 多介面實現

```
interface Runner {
    void run();
}

interface Swimmer {
    void swim();
}

class Athlete implements Runner, Swimmer {
    public void run() {
        System.out.println(10);  // 跑步
    }
    
    public void swim() {
        System.out.println(20);  // 游泳
    }
}

public class TestMultiInterface {
    public static void main(String[] args) {
        Athlete a = new Athlete();
        
        Runner r = a;
        r.run();     // 輸出 10
        
        Swimmer s = a;
        s.swim();    // 輸出 20
        
        System.out.println(99);
    }
}
```


### 介面繼承


```java
interface Animal {
    void makeSound();
}

interface Pet extends Animal {
    void play();
}

class Dog implements Pet {
    public void makeSound() {
        System.out.println(1);  // 汪
    }
    
    public void play() {
        System.out.println(2);  // 玩
    }
}

public class TestInterfaceInheritance {
    public static void main(String[] args) {
        Pet pet = new Dog();
        pet.makeSound();  // 輸出 1（來自 Animal 介面）
        pet.play();       // 輸出 2（來自 Pet 介面）
        
        Animal animal = pet;
        animal.makeSound();  // 輸出 1
        
        System.out.println(99);
    }
}
```

<br>

### 介面與 instanceof

```
interface Flyable {
    void fly();
}

class Bird implements Flyable {
    public void fly() {
        System.out.println(1);
    }
}

public class TestInterfaceInstanceof {
    public static void main(String[] args) {
        Bird bird = new Bird();
        
        if (bird instanceof Flyable) {
            System.out.println(10);  // 應輸出
        }
        
        Flyable f = bird;
        if (f instanceof Bird) {
            System.out.println(20);  // 應輸出
        }
        
        System.out.println(99);
    }
}
```


<br>

### 介面方法帶參數和返回值

```
interface Calculator {
    int add(int a, int b);
    int multiply(int a, int b);
}

class SimpleCalculator implements Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public int multiply(int a, int b) {
        return a * b;
    }
}

public class TestInterfaceWithParams {
    public static void main(String[] args) {
        Calculator calc = new SimpleCalculator();
        
        int sum = calc.add(3, 5);
        System.out.println(sum);  // 輸出 8
        
        int product = calc.multiply(4, 6);
        System.out.println(product);  // 輸出 24
    }
}
```


<br>

---


<br>

## MVP 限制與未來改進


### 目前簡化處理


| 項目             | 簡化方式         | 完整實現需求                                   |
|------------------|------------------|-----------------------------------------------|
| Default Method   | 基本支援         | 完整的菱形繼承（Diamond）解析                 |
| 私有介面方法     | 不支援           | 需支援 Java 9+ 的 private interface methods  |
| itable 優化      | 線性搜尋         | 使用 itable 加速介面方法查找                  |
| 介面靜態方法     | 基本支援         | 需要搭配 invokestatic 指令                   |


<br>

### 未來改進（v0.3.x+）

性能優化
* 實現 itable 快取介面方法偏移
* 內聯快取（inline cache）優化熱點調用

更完整的錯誤處理
* 更詳細的錯誤訊息
* 堆疊追蹤資訊

<br>

---

<br>

## 設計思考與總結

### 1. 為什麼 Java 選擇介面而非多重繼承？

多重繼承的問題：
- 鑽石問題（方法衝突）
- 狀態繼承複雜（多個父類的欄位）
- 建構子呼叫順序不明確

介面的優勢：
- 只有方法簽名，不存在狀態衝突
- 實現類必須提供實現，呼叫目標明確
- Java 8 的 default method 提供了有限的程式碼重用

###  2. `invokeinterface` 為什麼比 `invokevirtual` 慢？

`invokevirtual`:
- 使用 vtable，O(1) 查找
- 方法偏移量在編譯時就確定

`invokeinterface`:
- 無法使用簡單的 vtable
- 需要搜索 itable 或線性搜索
- 現代 JVM 使用各種優化來減少差距

### 3. GOGO JVM 的實現策略

學習目的優先：
- 使用簡單的線性搜索，易於理解

未來可擴展：
- 預留 itable 優化的空間
- 模組化設計便於替換實現


<br>

---

<br>

## 修改說明

* instructions/references/invokeinterface.go -> INVOKEINTERFACE 指令實現
* runtime/method_area/cp_interface_method_ref.go -> 修正後的 InterfaceMethodRef
* 











# v0.2.10：異常處理 (Exception Handling)

<br>

---

<br>

**目標**：實現 try-catch-finally 異常處理機制

1. 解析 Code 屬性中的異常表 (Exception Table)
2. 實現 `athrow`: `0xBF` 指令，功能是 __拋出異常__
3. 實現異常處理器查找邏輯
4. 實現棧展開 (Stack Unwinding)
5. 處理未捕獲異常的輸出

<br>

## 原理介紹

### Java 異常機制的本質 — 不只是錯誤處理

<br>

異常是一種 __控制流機制__，從 JVM 的角度來看，異常是一種特殊的控制流轉移機制，類似於 `goto`，但更加結構化：

<br>

**普通控制流**

* `if/else`, `for`, `while`, `switch`: 在同一個方法內跳轉
* `return`: 返回到調用者
* 方法調用: 進入新方法

<br>

**異常控制流**

* `throw`: 可能跨越多個方法，直接跳轉到某個 `catch` 區塊
* 這種 __"非局部跳轉"__ 是普通控制流做不到的

<br>

### 為什麼需要異常機制？

考慮一個深層的方法調用鏈:

```go
main() → processFile() → parseData() → readLine() → ... → 發生錯誤
```

__沒有異常機制時__，錯誤處理需要層層傳遞返回值，類似於 golang:

```go
func testFunc() error {
	return fmt.Error("test return error")
}
```

<br>

__有異常機制時__:

```java
try {
    processFile();  // 深層的錯誤會自動傳播上來
} catch (IOException e) {
    // 只在這裡處理
}
```

<br>

JVM 異常機制的設計哲學：__讓錯誤處理與正常邏輯分離__。

<br>

---

<br>

## ava 異常體系 — Throwable 繼承樹

```
                        ┌───────────┐
                        │ Throwable │
                        └─────┬─────┘
                              │
              ┌───────────────┴───────────────┐
              │                               │
        ┌─────┴─────┐                   ┌─────┴─────┐
        │   Error   │                   │ Exception │
        └─────┬─────┘                   └─────┬─────┘
              │                               │
    ┌─────────┼─────────┐           ┌─────────┼─────────────┐
    │         │         │           │         │             │
┌───┴───┐ ┌───┴───┐ ┌───┴───┐  ┌────┴────┐ ┌──┴──┐  ┌───────┴───────┐
│ OOM   │ │ Stack │ │ ...   │  │ Runtime │ │ IO  │  │    Checked    │
│ Error │ │ Over  │ │       │  │Exception│ │Excep│  │   Exception   │
└───────┘ │ flow  │ └───────┘  └────┬────┘ └─────┘  └───────────────┘
          └───────┘                 │
                          ┌─────────┼─────────┐
                          │         │         │
                    ┌─────┴─────┐ ┌─┴───┐ ┌───┴───────────┐
                    │ Arithmetic│ │Null │ │IndexOutOfBound│
                    │ Exception │ │Point│ │   Exception   │
                    └───────────┘ └─────┘ └───────────────┘
```

<br>

三種類型的差異:


| 類型               | 說明                                   | 是否需要捕獲 |
|--------------------|----------------------------------------|--------------|
| `Error`            | 系統級錯誤（如 JVM、記憶體不足），程式通常無法恢復 | 不需要（也不應該） |
| `RuntimeException` | 程式邏輯錯誤，可透過設計避免            | 不需要（Unchecked） |
| Checked Exception  | 外部因素導致（如 I/O、網路、資料庫錯誤） | 必須捕獲或宣告 |

<br>

從 JVM 的角度來看，所有異常都是 `Throwable` 物件，處理方式完全相同:

1. 異常物件被拋出 (`athrow`)
2. 查找異常表
3. 匹配則跳轉到 `handler`
4. 不匹配則棧展開

JVM 不區分 Checked 和 Unchecked，這是 Java 編譯器 的責任。

<br>

---

<br>

## 異常表 (Exception Table) — JVM 異常處理的核心

<br>

### 異常表的位置

異常表存放在方法的 Code 屬性中，與 bytecode 緊密綁定：

```
Code_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 max_stack;
    u2 max_locals;
    u4 code_length;
    u1 code[code_length];        // bytecode
    u2 exception_table_length;
    {   u2 start_pc;
        u2 end_pc;
        u2 handler_pc;
        u2 catch_type;
    } exception_table[exception_table_length];  // 異常表
    u2 attributes_count;
    attribute_info attributes[attributes_count];
}
```

<br>

### 異常表條目結構

```
Exception Table Entry:
┌───────────┬─────────┬───────────┬────────────┐
│ start_pc  │ end_pc  │ handler_pc│ catch_type │
│ (2 bytes) │(2 bytes)│ (2 bytes) │ (2 bytes)  │
├───────────┼─────────┼───────────┼────────────┤
│ try srart │ try end │catch entry│  ex type   │
└───────────┴─────────┴───────────┴────────────┘
```

catch_type 說明: 
* __非零值__: Constant Pool 的 Index，指向 `CONSTANT_Class`，表示要捕獲的異常類型
* __零值(`0`)__: 捕獲所有異常，用於 `finally { }` 區塊

<br>

### 範圍判斷規則

異常發生位置 pc 必須滿足：`start_pc <= pc < end_pc`

注意：左閉右開區間，這是 JVM 規範的設計。

<br>

### 為什麼 catch_type = 0 代表 finally?

`finally { }` 區塊需要捕獲所有異常（包括 `Throwable`），所以用 `0` 表示 "通配"。這樣一來：

* 不需要額外的標記位
* 不需要特殊的 opcode
* 復用現有的異常表結構

<br>

### 異常表的實際範例

原始 Java Code:

```java
public void test() {
    try {
        mayThrow();
    } catch (IOException e) {
        handleIO();
    } catch (Exception e) {
        handleOther();
    } finally {
        cleanup();
    }
}
```

編譯後的異常表:

| from | to | target | type                         |
|------|----|--------|------------------------------|
| 0    | 4  | 8      | `java/io/IOException`        |
| 0    | 4  | 16     | `java/lang/Exception`        |
| 0    | 4  | 24     | `any`（finally）             |
| 8    | 12 | 24     | `any`（finally）             |
| 16   | 20 | 24     | `any`（finally）             |


<br>

圖解說明:

```
Bytecode:
  0: aload_0
  1: invokevirtual mayThrow()V
  4: goto 28                      ← try 正常結束，跳過 catch
  ────────────────────────────────
  8: astore_1                     ← catch IOException 入口
  9: aload_0
 10: invokevirtual handleIO()V
 12: goto 28
  ────────────────────────────────
 16: astore_1                     ← catch Exception 入口
 17: aload_0
 18: invokevirtual handleOther()V
 20: goto 28
  ────────────────────────────────
 24: astore_2                     ← finally 入口
 25: aload_0
 26: invokevirtual cleanup()V
 27: athrow                       ← 重新拋出異常
  ────────────────────────────────
 28: aload_0                      ← 正常流程的 finally
 29: invokevirtual cleanup()V
 32: return
```

異常表對應關係：

```
  try 區塊 [0, 4)                                                  
    │                                                             
    ├─ 發生 IOException → 跳到 pc=8                                
    ├─ 發生其他 Exception → 跳到 pc=16                              
    └─ 發生任何異常（including Error）→ 跳到 pc=24                    
                                                                  
  catch IOException [8, 12)                                       
    └─ 發生任何異常 → 跳到 pc=24 (finally)                           
                                                                  
  catch Exception [16, 20)                                        
    └─ 發生任何異常 → 跳到 pc=24 (finally)                           
```

<br>

---

<br>

## `finally { }` 的實現機制 - 編譯處理

<br>

### `finally { }` 區塊的特殊性

`finally { }` 區塊無論是否發生異常都要執行，這帶來一個挑戰：

```java
try {
    return computeValue();  // 正常返回
} finally {
    cleanup();              // 必須執行
}
```

<br>

__JVM 的解決方案：代碼複製 (Code Duplication)__

編譯器會將 `finally { }` 區塊的代碼複製到每個可能的出口：

```
  Java 程式碼                  編譯後的 Bytecode                   
                                                                 
  try {                        try:                              
      return 1;                    iconst_1                      
  } finally {                      istore_1        // 暫存 int 返回值到 LocalVar[1]
      cleanup();       →           cleanup()       // finally 複製
  }                                iload_1         // 取回暫存的 int 返回值   
                                   ireturn         // 返回 int (1)             
                                                                 
                               exception_handler:                
                                   astore_2        // 存異常 ref 到 LocalVar[2]      
                                   cleanup()       // finally 複製
                                   aload_2         // 取異常      
                                   athrow          // 重新拋出
```

**這解釋了幾個現象:**

1. 為什麼 `finally { }` 中修改返回值無效？

    ```java
    int x = 1;            // x 原本位於 LocalVars[1]
       try {
           return x;      // x 的值已經被暫存到 LocalVars[2] 作為返回值暫存
       } finally {
           x = 2;         // 修改的是 LocalVars[1]，不是暫存的返回值 LocalVars[2] !!!
       }
       // 返回 1，不是 2
    ```
    
    注意: 這裡我寫註解 x 跟 return 暫存個放在 LocalVars 只是一個實作方式，並不是規範要求的。概念上就是 `try` 區塊中的 return 值需要被暫存，無論放在 LocalVars 或這 OpStack 都可以。
    
    __Java 規定：finally 一定會執行，但不能影響已決定的 return 值（除非 finally 自己 return）。__

    <br>

2. 為什麼 `finally { }` 中的 `return` 會覆蓋 `try  { }` 中的 `return`?

   ```java
      try {
       return 1;
   } finally {
       return 2;      // 這個 return 會覆蓋前面的
   }
   // 返回 2
   ```
   
   <br>

3. 為什麼 finally 中的異常會覆蓋 try 中的異常？
   
   ```java
      try {
       throw new Exception("A");
   } finally {
       throw new Exception("B");  // A 被丟棄
   }
   // 只有 Exception B 被拋出
   ```
   
<br>

---

<br>

## `athrow` 指令 — 異常拋出的起點

<br>

### 指令格式

```
athrow
opcode: 0xBF (191)
operands: 無
stack: [..., objectref] → objectref (異常物件)
```

<br>

### `athrow` 執行流程

1. 從操作數棧頂彈出異常物件引用 (`objectref`)
   * 如果 `objectref` 是 `null` → 拋出 `NullPointerException`

2. 在當前方法的異常表中查找匹配的 handler
   
   ```
   for each entry in exception_table: 
     if (start_pc <= pc < end_pc) {
       if (catch_type == 0 || objectref instanceof catch_type) {
           → 找到 handler 
       }
     }
   ```
   
3. 如果找到 handler:
   * 清空 op-Stack
   * 將異常物件 push 到 op-Stack
   * 跳轉到 handler_pc 繼續執行
   
4. 如果沒找到 handler:
   * pop 當前 Frame
   * 在調用者的 Frame 中重複 step 2 尋找 handler (棧展開)

5. 如果 JVMStack 空了都沒找到 handler
   * Thread 終止，印出異常信息和 stack 追蹤

<br>

---

<br>

## 棧展開 (Stack Unwinding) — 異常的傳播機制

### 什麼是棧展開?

當異常在當前方法找不到 handler 時，需要 "__展開__" 調用棧，回到調用者繼續查找。

```
方法調用鏈: main() → methodA() → methodB() → methodC()
                                            <error>
                                            
異常發生在 methodC()，沒有 handler：

┌─────────────┐
│ methodC     │ ← 異常發生點，找不到 handler → 彈出
├─────────────┤
│ methodB     │ ← 繼續查找，找不到 handler → 彈出
├─────────────┤
│ methodA     │ ← 找到 handler！清空 op-stack，跳轉到 catch
├─────────────┤
│ main        │
└─────────────┘
```

<br>

### 棧展開的實現邏輯

```go
func handleException(thread *Thread, exceptionObj *Object) {
    for {
        frame := thread.CurrentFrame()
        pc := thread.PC()
        
        // 在當前方法查找 handler
        handlerPC := findExceptionHandler(frame.Method(), exceptionObj.Class(), pc)
        
        if handlerPC >= 0 {
            // 找到 handler
            handleCatch(frame, exceptionObj, handlerPC)
            return
        }
        
        // 沒找到，彈出當前 Frame（棧展開）
        thread.PopFrame()
        
        if thread.IsStackEmpty() {
            // 棧空了，未捕獲異常
            handleUncaughtException(thread, exceptionObj)
            return
        }
    }
}

func handleCatch(frame *Frame, exceptionObj *Object, handlerPC int) {
    stack := frame.OperandStack()
    stack.Clear()                    // 清空操作數棧
    stack.PushRef(exceptionObj)      // 異常物件入棧（給 catch 區塊用）
    frame.SetNextPC(handlerPC)       // 跳轉到 handler
}
```

<br>

### 為什麼要清空操作數棧?

**考慮以下情況**:

```java
int result = a + b / c;  // 假設 c = 0，在計算 b/c 時拋異常
```

Bytecode 執行到一半時：

```
stack: [a, b, c]
       ↑
       執行 idiv 時發生 ArithmeticException
```

此時 op-stack 上的 `a`, `b`, `c` 都是 "__半成品__"，對 `catch { }` 區塊沒有意義。

__JVM 規範要求：進入 catch 區塊時，操作數棧只有異常物件。__


<br>

---

<br>

## 異常處理器匹配規則

### 類型匹配的判斷

```go
func canCatch(catchType *Class, exceptionClass *Class) bool {
    // catch_type == 0 表示捕獲所有（finally）
    if catchType == nil {
        return true
    }
    
    // 檢查異常類是否為 catchType 或其子類
    return exceptionClass.IsAssignableFrom(catchType)
}
```

<br>

### 繼承關係的影響

```java
try {
    throw new FileNotFoundException();
} catch (IOException e) {
    // FileNotFoundException 是 IOException 的子類
    // 所以這裡會被捕獲
}
```

<br>

### 異常表的順序很重要

```java
try {
    // ...
} catch (FileNotFoundException e) {  // 具體類型在前
    // ...
} catch (IOException e) {            // 通用類型在後
    // ...
}
```

如果順序反過來，`FileNotFoundException` 永遠不會被捕獲，因為會先匹配到 `IOException`。

__Java 編譯器會檢查這種錯誤，但 JVM 本身不檢查 — 它只是按異常表順序匹配。__

<br>

---

<br>

## JVM 內建異常的觸發 — 隱式異常

### 除了 `athrow` 顯式拋出，很多指令會隱式觸發異常:

**JVM 指令 / 情況觸發的例外與錯誤**

| 指令 / 情況                     | 觸發條件                   | 例外 / 錯誤類型                 |
|--------------------------------|----------------------------|----------------------------------|
| `idiv`, `irem`                 | 除數為 0                   | `ArithmeticException`            |
| `aaload`, `iaload` 等           | 陣列索引越界               | `ArrayIndexOutOfBoundsException` |
| `getfield`, `putfield`         | 物件引用為 `null`          | `NullPointerException`           |
| `invokevirtual`                | 物件引用為 `null`          | `NullPointerException`           |
| `checkcast`                    | 類型不相容                 | `ClassCastException`             |
| `anewarray`                    | 陣列長度為負               | `NegativeArraySizeException`     |
| `new`                          | 嘗試建立抽象類或介面實例   | `InstantiationError`             |
| （方法遞迴過深）               | 呼叫堆疊溢位               | `StackOverflowError`             |
| （配置物件 / 陣列失敗）        | 記憶體不足                 | `OutOfMemoryError`               |


<br>

### 目前 GOGO JVM 的處理

在 v0.2.10 之前，這些情況使用 Go 的 panic:

```go
// instructions/math/arithmetic.go
func (i *IDIV) Execute(frame *runtime.Frame) {
    v2 := stack.PopInt()
    v1 := stack.PopInt()
    if v2 == 0 {
        panic("java.lang.ArithmeticException: / by zero")  // 目前做法
    }
    // ...
}
```

**v0.2.10 的改進方向**

將 panic 改為拋出真正的 Java 異常物件：

```go
func (i *IDIV) Execute(frame *runtime.Frame) {
    v2 := stack.PopInt()
    v1 := stack.PopInt()
    if v2 == 0 {
        // 創建並拋出 ArithmeticException
        exceptionObj := createArithmeticException(frame, "/ by zero")
        throwException(frame.Thread(), exceptionObj)
        return
    }
    // ...
}
```

<br>

---

<br>

## 異常物件的結構

### Java 異常物件的欄位

```java
class Throwable {
    private String detailMessage;           // 錯誤訊息
    private Throwable cause;                // 原因（鏈式異常）
    private StackTraceElement[] stackTrace; // 堆疊追蹤
    // ...
}
```

<br>

### MVP 階段的簡化設計

完整實現需要載入 `java.lang.Throwable` 類別，這涉及大量依賴。

MVP 階段採用 HACK 方式:

```go
// runtime/heap/exception.go

// ExceptionObject 簡化的異常物件
type ExceptionObject struct {
    *Object                          // 繼承 Object
    exceptionClass *Class            // 異常類型（如 ArithmeticException）
    detailMessage  string            // 錯誤訊息
    stackTrace     []*StackTraceEntry // 堆疊追蹤
}

type StackTraceEntry struct {
    className  string  // 類名
    methodName string  // 方法名
    fileName   string  // 檔案名
    lineNumber int     // 行號（目前用 PC 代替）
}
```

<br>

---

<br>

## 從 classfile 到 runtime 的映射

### classfile 層

```go
// classfile/member_attribute_info.go

type ExceptionHandler struct {
    startPc   uint16
    endPc     uint16
    handlerPc uint16
    catchType uint16  // 常量池索引
}

type CodeAttribute struct {
    // ...
    exceptionTable []*ExceptionHandler
    // ...
}
```

<br>

### runtime 層

```go
// runtime/method_area/exception_table.go

// ExceptionHandler 運行時異常處理器
type ExceptionHandler struct {
    StartPC   int
    EndPC     int
    HandlerPC int
    CatchType *ClassRef  // 解析後的類引用（nil 表示 finally）
}

// ExceptionTable 異常表
type ExceptionTable []*ExceptionHandler

// FindExceptionHandler 查找匹配的異常處理器
// 參數：
//   - exClass: 異常物件的類
//   - pc: 當前程序計數器
// 返回：
//   - handlerPC: 找到則返回 handler 入口，否則返回 -1
func (table ExceptionTable) FindExceptionHandler(exClass *Class, pc int) int {
    for _, handler := range table {
        // 檢查 PC 是否在範圍內 [start_pc, end_pc)
        if pc >= handler.StartPC && pc < handler.EndPC {
            // 檢查類型是否匹配
            if handler.CatchType == nil {
                // catch_type == 0，捕獲所有（finally）
                return handler.HandlerPC
            }
            
            catchClass := handler.CatchType.ResolvedClass()
            if catchClass.IsAssignableFrom(exClass) {
                return handler.HandlerPC
            }
        }
    }
    return -1
}
```

<br>

### Method 結構的擴展

```go
// runtime/method_area/rtma_method.go

type Method struct {
    // ... 現有欄位 ...
    exceptionTable ExceptionTable  // 新增：異常表
}

// copyAttributes 需要修改，解析異常表
func (m *Method) copyAttributes(cfMethod *classfile.MemberInfo) {
    if codeAttr := cfMethod.CodeAttribute(); codeAttr != nil {
        m.maxStack = codeAttr.MaxStack()
        m.maxLocals = codeAttr.MaxLocals()
        m.code = codeAttr.Code()
        m.exceptionTable = newExceptionTable(codeAttr.ExceptionTable(), m.class.constantPool)
    }
}

// ExceptionTable getter
func (m *Method) ExceptionTable() ExceptionTable {
    return m.exceptionTable
}
```

<br>

---

<br>

## `athrow` 指令實現 - `0xBF`

### 指令結構

1. 從棧頂彈出異常物件
2. 如果異常引用為 null，拋出 NullPointerException
3. 查找並處理異常
4. 如果未捕獲異常，處理並終止

<br>

### 異常處理核心邏輯

處理異常，返回是否成功捕獲

1. 在當前方法的異常表中查找 handler
2. 如果找到 handler:
   3. 清空操作數棧
   4. 將異常物件 push 到棧（給 catch 區塊使用）
   5. 跳轉到 handler (PC)
6. 如果沒找到 handler:
   7. 棧展開 (Stack Unwinding)，彈出當前 Frame
   8. 如果 Stack Empty 代表沒有捕到異常 -> 處理未捕獲異常 `handleUncaughtException()`

<br>

---

<br>

## 修改現有的隱式異常

以 `idiv` 為例，將 panic 改為拋出真正的異常：

```go
// instructions/math/arithmetic.go

func (i *IDIV) Execute(frame *runtime.Frame) {
    stack := frame.OperandStack()
    v2 := stack.PopInt()
    v1 := stack.PopInt()
    
    if v2 == 0 {
        // 創建 ArithmeticException 物件
        thread := frame.Thread()
        exceptionObj := heap.NewArithmeticException("/ by zero")
        
        // 拋出異常
        if !handleException(thread, exceptionObj) {
            handleUncaughtException(thread, exceptionObj)
        }
        return
    }
    
    result := v1 / v2
    stack.PushInt(result)
}
```

### 異常物件的創建（MVP 簡化版）

```go
// runtime/heap/exception.go

package heap

// NewArithmeticException 創建 ArithmeticException
func NewArithmeticException(message string) *Object {
    // MVP：使用簡化的異常物件
    // TODO: 真正載入 java/lang/ArithmeticException 類
    return &Object{
        class: nil,  // TODO: 指向真正的異常類
        extra: &ExceptionInfo{
            className: "java/lang/ArithmeticException",
            message:   message,
        },
    }
}

// NewNullPointerException 創建 NullPointerException
func NewNullPointerException() *Object {
    return &Object{
        class: nil,
        extra: &ExceptionInfo{
            className: "java/lang/NullPointerException",
            message:   "",
        },
    }
}

// ExceptionInfo 異常資訊（MVP 簡化版）
type ExceptionInfo struct {
    className string
    message   string
}

// IsException 檢查物件是否為異常
func (o *Object) IsException() bool {
    _, ok := o.extra.(*ExceptionInfo)
    return ok
}

// ExceptionClassName 獲取異常類名
func (o *Object) ExceptionClassName() string {
    if info, ok := o.extra.(*ExceptionInfo); ok {
        return info.className
    }
    return ""
}

// ExceptionMessage 獲取異常訊息
func (o *Object) ExceptionMessage() string {
    if info, ok := o.extra.(*ExceptionInfo); ok {
        return info.message
    }
    return ""
}
```

<br>

---

<br>

## v0.2.10 實現清單

### 1. classfile 層擴展
- `classfile/member_attribute_info.go`
   - 為 `ExceptionHandler` 添加 getter 方法
   - 為 `CodeAttribute` 添加 `ExceptionTable()` 方法

<br>

### 2. runtime/method_area 擴展
- `runtime/method_area/exception_table.go`（新增）
   - 定義 `ExceptionHandler` 結構
   - 定義 `ExceptionTable` 類型
   - 實作 `FindExceptionHandler()` 方法
- `runtime/method_area/rtma_method.go`（修改）
   - 新增 `exceptionTable` 欄位
   - 修改 `copyAttributes()`，解析並載入異常表
   - 新增 `ExceptionTable()` getter 方法

<br>

### 3. runtime/heap 擴展
- `runtime/heap/exception.go`（新增）
   - 定義 `ExceptionInfo` 結構
   - 新增例外建構方法：
      - `NewArithmeticException()`
      - `NewNullPointerException()`
   - 提供輔助判斷方法：
      - `IsException()`
      - `ExceptionClassName()` 等

<br>

### 4. runtime 擴展
- `runtime/operand_stack.go`（修改）
   - 新增 `Clear()` 方法（用於例外處理流程）

<br>

### 5. instructions 擴展
- `instructions/references/athrow.go`（新增）
   - 定義 `ATHROW` 指令結構
   - 實作 `handleException()` 核心邏輯
   - 實作 `handleUncaughtException()` 處理未捕獲例外
- `instructions/base/opcodes/opcodes.go`（修改）
   - 新增 `ATHROW = 0xBF`
- `instructions/factory.go`（修改）
   - 註冊 `ATHROW` 指令至指令工廠

<br>

### 6. 修改現有指令（可選，用於完善隱式例外）
- `instructions/math/arithmetic.go`
   - 為以下指令新增除零檢查：
      - `IDIV`
      - `LDIV`
      - `IREM`
      - `LREM`



<br>

---

<br>

## 測試案例


### 基本 try-catch

```java
public class TestBasicCatch {
    public static void main(String[] args) {
        try {
            int x = 1 / 0;
            System.out.println(0);  // 不應該執行
        } catch (ArithmeticException e) {
            System.out.println(1);  // 應輸出 1
        }
        System.out.println(2);      // 應輸出 2
    }
}
```

<br>

### 顯式 throw

```java
public class TestThrow {
    public static void main(String[] args) {
        try {
            throwIt();
        } catch (RuntimeException e) {
            System.out.println(1);  // 應輸出 1
        }
        System.out.println(2);      // 應輸出 2
    }
    
    public static void throwIt() {
        throw new RuntimeException();
    }
}
```

<br>

### 棧展開

```java
public class TestStackUnwinding {
    public static void main(String[] args) {
        try {
            methodA();
        } catch (Exception e) {
            System.out.println(4);  // 應輸出 4
        }
        System.out.println(5);      // 應輸出 5
    }
    
    public static void methodA() {
        System.out.println(1);      // 應輸出 1
        methodB();
        System.out.println(99);     // 不應該執行
    }
    
    public static void methodB() {
        System.out.println(2);      // 應輸出 2
        methodC();
        System.out.println(99);     // 不應該執行
    }
    
    public static void methodC() {
        System.out.println(3);      // 應輸出 3
        throw new RuntimeException();
    }
}
```

<br>

### 多層 catch

```java
public class TestMultiCatch {
    public static void main(String[] args) {
        test(1);  // ArithmeticException
        test(2);  // NullPointerException (模擬)
        test(3);  // 其他 Exception
    }
    
    public static void test(int type) {
        try {
            if (type == 1) {
                int x = 1 / 0;
            } else if (type == 2) {
                throw new NullPointerException();
            } else {
                throw new Exception();
            }
        } catch (ArithmeticException e) {
            System.out.println(10);
        } catch (NullPointerException e) {
            System.out.println(20);
        } catch (Exception e) {
            System.out.println(30);
        }
    }
}
```

<br>

### finally 區塊

```java
public class TestFinally {
    public static void main(String[] args) {
        try {
            System.out.println(1);
            int x = 1 / 0;
        } catch (ArithmeticException e) {
            System.out.println(2);
        } finally {
            System.out.println(3);  // 無論如何都執行
        }
        System.out.println(4);
    }
}
```

<br>

---

<br>

## MVP 限制與未來改進

### 目前簡化處理
| 項目             | 簡化方式                                   | 完整實現需求                          |
|------------------|--------------------------------------------|---------------------------------------|
| 異常類載入       | 使用 `ExceptionInfo` hack                  | 載入真正的 `java.lang.*` 異常類        |
| 堆疊追蹤         | 不輸出或僅簡單輸出                         | 輸出完整 `StackTraceElement`          |
| 行號資訊         | 不處理                                     | 使用 PC 解析 `LineNumberTable`         |
| 異常訊息         | 使用簡單字串                               | 正確設定 `detailMessage` 欄位          |
| 鏈式異常         | 不支援                                     | 支援 `cause` 欄位（例外鏈）|


<br>

### 未來改進（v0.3.x+）

1. 完整的異常類別系統
   * 載入 `java.lang.Throwable` 及其子類
   * 正確初始化異常物件的欄位
2. 堆疊追蹤 (Stack Trace)
   * 解析 `LineNumberTable` 屬性
   * 實現 `fillInStackTrace()` native 方法
   * 格式化輸出堆疊追蹤
3. 更多隱式異常
   * `ArrayIndexOutOfBoundsException`
   * `ClassCastException`
   * `NegativeArraySizeException`

   
<br>

---

<br>

## JVM 異常處理的設計總結

### 1. 異常表（Exception Table）的設計
**為什麼異常表放在 `Code` 屬性中？**

- 異常處理與 bytecode 緊密綁定
   - `start_pc`、`end_pc`、`handler_pc` 都是 **bytecode 偏移量**
- 在 `ClassLoader` 載入階段即可一次完成解析
- 執行期可直接使用，**無需額外的間接尋址**
- 將「控制流異常」視為 **方法實作的一部分**

### 2. `catch_type = 0` 的巧思
**為什麼用 `0` 表示 `finally`？**

- 復用既有的 Exception Table 結構
- 不需要引入額外標記或特殊資料結構
- 判斷邏輯簡單、效能高
- 語義非常清楚：**「捕獲所有例外」**

> `catch_type = 0` 本質上就是 JVM 層級的 `catch (Throwable)`。

### 3. 棧展開（Stack Unwinding）的設計
**為什麼直接復用方法調用棧？**

- 不需要維護額外的「異常棧」
- 自然實現例外的向上傳播語義
- 與方法呼叫 / 返回的控制流程完全一致
- 簡化 JVM 實作，同時保持語義正確

### 4. 清空操作數棧（Operand Stack）
**為什麼進入 `catch` 前必須清空操作數棧？**

- 異常發生時，棧上可能存在：
   - 尚未完成的運算結果
   - 中間狀態的「半成品資料」
- 清空操作數棧可保證：
   - `catch` 區塊在 **乾淨、可預期的執行環境** 中開始
- 進入 `catch` 時：
   - **異常物件是唯一需要的輸入**

### 5. 異常物件的傳遞方式
**為什麼要把異常物件 push 到操作數棧？**

- 統一的資料傳遞模型：**一切皆經由操作數棧**
- `catch` 區塊可使用：
   - `astore` 將異常物件存入局部變數
- 完全符合 JVM 既有的指令與執行模型
- 無需為異常引入特殊通道或規則


<br>

---

<br>


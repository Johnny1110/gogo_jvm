# v0.2.10：異常處理

<br>

---

<br>

**目標**：實現 try-catch-finally 異常處理機制

**需要實現的指令**：

| 指令 | Opcode | 功能 |
|------|--------|------|
| `athrow` | `0xBF` | 拋出異常 |

<br>

**設計要點**：

異常表結構（每個方法的 Code 屬性中）：

```
Exception Table Entry:
┌───────────┬─────────┬──────────┬────────────┐
│ start_pc  │ end_pc  │handler_pc│ catch_type │
├───────────┼─────────┼──────────┼────────────┤
│ try 開始  │ try 結束│catch 入口│ 捕獲的異常類│
└───────────┴─────────┴──────────┴────────────┘

catch_type = 0 表示 finally（捕獲所有異常）
```

<br>

**異常處理流程**：

```
athrow 執行時：
1. 從棧頂取得異常物件
2. 在當前方法的異常表中查找匹配的 handler
3. 如果找到 → 跳轉到 handler_pc 繼續執行
4. 如果找不到 → 彈出當前 Frame，在調用者中繼續查找
5. 如果棧空了還沒找到 → 線程終止，打印異常信息
```

<br>

**棧展開 (Stack Unwinding)**：

```
┌─────────────┐
│ methodC     │ ← 異常發生點，找不到 handler
├─────────────┤
│ methodB     │ ← 繼續查找，找不到 handler  
├─────────────┤
│ methodA     │ ← 找到 handler！跳轉到 catch 塊
├─────────────┤
│ main        │
└─────────────┘
```

<br>

**需要解析的屬性**：

```go
// classfile/attr_code.go
type ExceptionTableEntry struct {
    StartPc   uint16  // try 塊開始位置
    EndPc     uint16  // try 塊結束位置
    HandlerPc uint16  // catch 處理器入口
    CatchType uint16  // 捕獲的異常類型（常量池索引，0=finally）
}
```

<br>

**測試目標**：

```java
public class TestException {
    public static void main(String[] args) {
        try {
            int x = 1 / 0;
        } catch (ArithmeticException e) {
            System.out.println(1);  // 應輸出 1
        }
        
        try {
            throwIt();
        } catch (RuntimeException e) {
            System.out.println(2);  // 應輸出 2
        }
        
        System.out.println(3);      // 應輸出 3
    }
    
    public static void throwIt() {
        throw new RuntimeException();
    }
}
```

<br>
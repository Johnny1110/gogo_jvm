# v0.2.8：類型系統增強 - `instanceof` / `checkcast` / `anewarray`

<br>

---

<br>

**目標**：完善物件類型系統，支援類型檢查與引用類型陣列

**需要實現的指令**：

| 指令 | Opcode | 功能 |
|------|--------|------|
| `instanceof` | `0xC1` | 判斷物件是否為指定類型的實例 |
| `checkcast` | `0xC0` | 類型強制轉換（失敗拋 ClassCastException） |
| `anewarray` | `0xBD` | 建立引用類型陣列（如 `String[]`） |

<br>

**設計要點**：

`instanceof` 的判斷邏輯：

```
obj instanceof T 的判斷規則：
1. 如果 obj 是 null → 返回 false
2. 如果 obj.class == T → 返回 true
3. 如果 T 是 class → 檢查 obj.class 的繼承鏈是否包含 T
4. 如果 T 是 interface → 檢查 obj.class 是否實現了 T
5. 如果 T 是陣列類型 → 特殊處理
```

<br>

`checkcast` 與 `instanceof` 的差異：

```
instanceof: 返回 boolean（true/false）
checkcast:  成功則不做任何事，失敗則拋出 ClassCastException
```

<br>

`anewarray` 與 `newarray` 的差異：

```
newarray:   建立基本類型陣列（int[], byte[], ...）
anewarray:  建立引用類型陣列（String[], Object[], ...）
```

<br>

**需要完善的模組**：

```go
// runtime/method_area/class.go
// 新增方法：

// IsAssignableFrom 判斷 this 是否是 other 的父類或介面
func (c *Class) IsAssignableFrom(other *Class) bool

// IsSubClassOf 判斷 this 是否是 target 的子類
func (c *Class) IsSubClassOf(target *Class) bool

// IsImplements 判斷 this 是否實現了 iface 介面
func (c *Class) IsImplements(iface *Class) bool
```

<br>

**測試目標**：

```java
public class TestTypeSystem {
    public static void main(String[] args) {
        // 測試 instanceof
        Animal dog = new Dog();
        if (dog instanceof Dog) {
            System.out.println(1);  // 應輸出 1
        }
        
        // 測試 checkcast
        Dog d = (Dog) dog;
        d.bark();  // 應輸出 10
        
        // 測試 anewarray
        Animal[] animals = new Animal[3];
        animals[0] = new Dog();
        animals[1] = new Cat();
        animals[0].speak();  // 應輸出 100
        animals[1].speak();  // 應輸出 200
        
        System.out.println(999);  // 全部測試通過
    }
}

class Animal {
    public void speak() { System.out.println(0); }
}

class Dog extends Animal {
    public void speak() { System.out.println(100); }
    public void bark() { System.out.println(10); }
}

class Cat extends Animal {
    public void speak() { System.out.println(200); }
}
```

預期輸出：

```
1
10
100
200
999
```

<br>

---

<br>

## JVM 類型檢查的設計哲學

### 為什麼需要 instanceof 和 checkcast？

Java 是靜態類型語言，但支援多型（Polymorphism）。這帶來一個問題：

```java
Object obj = getFromSomewhere();  // 編譯時只知道是 Object
// 執行時，obj 可能是 String、Integer、或任何類型
```

編譯器無法確定執行時的真實類型，所以需要：

* `instanceof`：安全地檢查類型
* `checkcast`：強制轉換（失敗會拋異常）

<br>

### JVM 規範中的類型檢查規則

JVM 規範 (JVMS 6.5) 定義了完整的類型檢查規則：

```
S instanceof T 或 S checkcast T 的判斷規則：
┌─────────────────────────────────────────────────────────────────┐
│ 情況 1：S 和 T 都是 Class 類型                                   │
├─────────────────────────────────────────────────────────────────┤
│ • S == T → true                                                 │
│ • S 是 T 的子類 → true                                          │
│ • 否則 → false                                                  │
├─────────────────────────────────────────────────────────────────┤
│ 情況 2：T 是 Interface 類型                                      │
├─────────────────────────────────────────────────────────────────┤
│ • S 實現了 T → true                                             │
│ • S 的任何父類實現了 T → true                                    │
│ • 否則 → false                                                  │
├─────────────────────────────────────────────────────────────────┤
│ 情況 3：S 是 Array 類型 S[]                                      │
├─────────────────────────────────────────────────────────────────┤
│ • T 是 Object → true（所有陣列都是 Object 的子類）               │
│ • T 是 Cloneable → true（JLS 規定）                             │
│ • T 是 Serializable → true（JLS 規定）                          │
│ • T 是 E[] 且 S 可賦值給 E → true                               │
│ • 否則 → false                                                  │
└─────────────────────────────────────────────────────────────────┘
```

<br>

### instanceof vs checkcast 的差異

|                | instanceof         | checkcast             |
|----------------|---------------------|------------------------|
| null 處理      | 返回 false         | 通過（不拋異常）        |
| 類型匹配       | 返回 true          | 通過                   |
| 類型不匹配     | 返回 false         | ClassCastException     |
| Stack 效果     | pop ref, push int  | 不變（ref 留在棧上）    |

為什麼 checkcast 對 null 不拋異常？

這是 Java 語言設計的選擇：

```java
String s = (String) null;  // 這是合法的！
```

因為 `null` 可以賦值給任何引用類型。


<br>

---

<br>

## 陣列類型系統

### 1. JVM 陣列類型的命名規則

| Java 類型      | JVM 內部名稱             |
|----------------|---------------------------|
| int[]          | [I                        |
| long[]         | [J                        |
| byte[]         | [B                        |
| boolean[]      | [Z                        |
| char[]         | [C                        |
| short[]        | [S                        |
| float[]        | [F                        |
| double[]       | [D                        |
| Object[]       | [Ljava/lang/Object;       |
| String[]       | [Ljava/lang/String;       |
| int[][]        | [[I                       |
| String[][]     | [[Ljava/lang/String;      |


<br>

### 2. `newarray` vs `anewarray` vs `multianewarray`

| 指令           | 用途                                          |
|----------------|-----------------------------------------------|
| newarray       | 建立基本類型陣列：int[], byte[], char[] 等    |
| anewarray      | 建立引用類型陣列：String[], Object[] 等       |
| multianewarray | 建立多維陣列：int[][], String[][] 等          |

<br>

### 3. 陣列的特殊繼承關係

Java 陣列有一個特殊的繼承結構：

```
                    Object
                       ▲
          ┌────────────┼────────────┐
          │            │            │
     Cloneable    Serializable    其他類
          ▲            ▲
          │            │
          └─────┬──────┘
                │
             所有陣列
          ┌─────┴─────┐
          │           │
        int[]     String[]
```

這意味著：

```
int[] arr = new int[5];
arr instanceof Object       // true!
arr instanceof Cloneable    // true!
arr instanceof Serializable // true!
```

<br>
<br>

## 實現檔案清單

* instructions/references/instanceof_checkcast.go - `instanceof` 和 `checkcast` 指令
* instructions/arrays/anewarray.go - `anewarray` 指令
* instructions/base/opcodes/opcodes.go - 加入 `INSTANCEOF`, `CHECKCAST` 常數
* instructions/factory.go - 註冊新指令

<br>
<br>

## MVP 限制與未來改進

### 目前簡化處理

* 陣列類型系統不完整：完整實現需要動態生成陣列類別
* aastore 類型檢查：目前不檢查元素類型相容性
* 陣列協變：未處理 Object[] arr = new String[5] 的情況

### 未來改進（v0.3.x）

* 完整的陣列類別系統
* ArrayStoreException 檢查
* 完善的 Class 物件支援

<br>
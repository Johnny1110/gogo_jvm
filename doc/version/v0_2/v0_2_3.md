# v0.2.3: Basic Method Area Implementation

<br>

---

<br>

目標：

1. 實現 JVM 方法區
    * ClassLoader
    * RuntimeConstantPool
    * ClassRef, FieldRef, MethodRef
    * Class, Field, Method
2. 實現 `INVOKE_STATIC` 指令 (靜態方法呼叫)

<br>

* 測試目標：

```java
public class Fibonacci {
    public static void main(String[] args) {
        int result = fib(10);
    }

    public static int fib(int n) {
        if (n <= 1) return n;
            return fib(n-1) + fib(n-2);
    }
 }
```

<br>
<br>

這是 Java 運行時區域的 Method Area，這個區域的資料是 Thread 共享的。

<br>

## 重要核心組成

* ClassLoader -> 負責將 class 完整載入 (從 classfile bytecode 開始解析)
    * tip-1: [為什麼類別的 static field slot ID 計算時不需要考慮婦類別？](../../tips/class_loader_cal_field_slot_id.md)

* RuntimeConstantPool -> 運行時常量池 (每一個 class 都有一個自己專用，用於存放 class constant)
    * ClassRef -> 指向 Class 實例的直接引用 (RuntimeConstantPool 專用)
    * FieldRef -> 指向 Field 實例的直接引用 (RuntimeConstantPool 專用)
    * MethodRef -> 指向 Method 實例的直接引用 (RuntimeConstantPool 專用)
    * InterfaceMethodRef -> 指向 Method 實例的直接引用 (RuntimeConstantPool 專用)

* Class-> Class 的實例，被 ClassLoader 載入完畢後的 classfile 就變成它，並存在 ClassLoader 裡面 (同一個類只會被載入一次)
* Field -> Class 的 field 實例
* Method -> Class 的 method 實例

* MethodDescriptor -> 方法的 descriptor 解析，將純字面量解構成資料結構。

<br>
<br>

接下來的重點就是逐步拆解每一個重要的組成單元，看看他們是如何組在一起就能拼湊出 JVM Method Area 的。

<br>

---

<br>

## ClassLoader 類別加載器

ClassLoader 是 JVM 中負責 載入 class 檔案 到記憶體並建立 Class 物件的核心元件。
它知道去哪裡找 .class，怎麼讀、怎麼驗證、怎麼放到 JVM 裡。

<br>

### 類加載流程：
```
 ┌─────────────────────────────────────────────────────────┐
 │  Loading → Linking → Initialization                     │
 │                                                         │
 │  Loading:                                               │
 │    - 讀取 .class 文件                                    │
 │    - 解析成 ClassFile                                   │
 │    - 轉換成 Class                                       │
 │                                                         │
 │  Linking:                                               │
 │    - Verification: 驗證字節碼（簡化跳過）                   │
 │    - Preparation: 為靜態變量分配空間                       │
 │    - Resolution: 符號引用解析（懶加載）                     │
 │                                                         │
 │  Initialization:                                        │
 │    - 執行 <clinit> 方法（靜態初始化）                       │
 └─────────────────────────────────────────────────────────┘
```

**ClassLoader 的主要任務**

1. 將 .class 載入 JVM（Load）

    * 從 dir，JAR 等地方把 .class bytecode 資料讀出來。
    * 這裡會使用遞迴的方式一直向上載入 parent class 與 interfaces 直到所依賴的上層類別全部被載入為止。

2. 驗證 class 是否合法（Verify）

    * 確保 bytecode 合法，不會破壞 JVM。

3. 轉換成 JVM 裡的資料結構（Prepare / Resolve）

    * 透過 classfile 建立 RuntimeConstantPool，分配靜態變數空間等。

4. 建立 java.lang.Class 物件

    * 保證類的唯一性（同一個類只加載一次）
    * 這個物件是 Class 在 JVM 內的 metadata (其實就放在 ClassLoader 內的一個 map 裏做緩存)。

<br>
<br>

### 分配靜態變數空間

分配靜態變數空間是在 `link` 階段實現，也就是在一個 class 已經被建立出來之後，我們仍需要知道一個類別的每一個靜態變量對應 `staticVars` 的哪一個索引。

```go
func prepare(class *Class) {
	// 計算非靜態 Fields slot 數量
	calcInstanceFieldSlotIds(class)
    // 計算靜態 Fields slot 數量
	calcStaticFieldSlotIds(class)
	// 分配並初始化 Vars 表
    allocAndInitVars(class)
}
```

<br>

**計算非靜態 Fields slot 數量**

```go
func calcInstanceFieldSlotIds(class *Class) {
	slotId := uint(0)
	
	if class.superClass != nil {
		// 父類別的先佔走一定數量
		slotId = class.superClass.instanceSlotCount
	}
	for _, field := range class.fields {
		if !field.IsStatic() { // 只看非 static fields
			field.slotId = slotId
			slotId++
			if field.isLongOrDouble() { // long 跟 double ˊ佔 2 個 slot 空間，多加一格
				slotId++
			}
		}
	}

	class.instanceSlotCount = slotId
}
```

<br>

**計算靜態 Fields slot 數量**

```go
func calcStaticFieldSlotIds(class *Class) {
	slotId := uint(0)
	for _, field := range class.fields {
		if field.IsStatic() { // 只看 static fields
			field.slotId = slotId
			slotId++
			if field.isLongOrDouble() { // long 跟 double ˊ佔 2 個 slot 空間，多加一格
				slotId++
			}
		}
	}
	class.staticSlotCount = slotId
}
```

<br>

**分配並初始化 Vars 表**

```go
func allocAndInitVars(class *Class) {
   class.instanceVars = rtcore.NewSlots(class.instanceSlotCount)
   class.staticVars = rtcore.NewSlots(class.staticSlotCount)
   // TODO: 初始化 static final 常量
}
```

<br>

---

<br>

## RuntimeConstantPool 運行時常量池

RuntimeConstantPool 是 ClassFileConstantPool 載入後（由 ClassLoader + JVM）放入 method area 的結構。
JVM 執行時使用這個 pool 來解析符號引用 → 變成直接引用（指標）

__每個 Class 在 JVM 裡都有自己的 runtime constant pool。__

比較直觀一點看：

```
 ┌────────────────────────────────────────────────────────┐
 │  ClassFileConstantPool（Compile）                       │
 │  #1 Methodref → class=#2, nameAndType=#3               │
 │  #2 Class → name=#4                                    │
 │  #3 NameAndType → name=#5, desc=#6                     │
 │  #4 Utf8 → "Calculator"                                │
 │  #5 Utf8 → "add"                                       │
 │  #6 Utf8 → "(II)I"                                     │
 └────────────────────────────────────────────────────────┘
                        ↓ parse
 ┌────────────────────────────────────────────────────────┐
 │  RumtimeConstantPool                                   │
 │  #1 MethodRef → pointing to Calculator.add()           │
 └────────────────────────────────────────────────────────┘
```

結構：

```go
type RuntimeConstantPool struct {
   class  *Class        // 所屬的 class
   consts []Constant    // 常量表，裡面可以存直接引用或者 int long float double 等
}
````

跟 ClassFileConstantPool 一樣，索引要從 1 開始。

在實際代碼 `func newRuntimeConstantPool(class *Class, cfCp classfile.ClassFileConstantPool) *RuntimeConstantPool { ... }`

我們可以看到基本上會把 ClassFileConstantPool 中的每一個 ConstantInfo 轉換成更能直接可用的 Constant 並存入 `consts` 中

* RuntimeConstantPool 的常量表索引跟 ClassFileConstantPool 保持一致。
* Utf8 與 NameAndType 類型的 `ConstantInfo` 不需要處理，因為他們在 `MemberConstantInfo` 轉換階段已經被利用完，沒有剩餘價值了。

<br>

### 符號引用 (ClassFileConstantPool) vs 直接引用 (RuntimeConstantPool)

這是 JVM 規範中的核心概念：

```
編譯時（ClassFile）                    運行時（解析後）
┌─────────────────────────┐           ┌─────────────────────────┐
│ ClassFileConstantPool   │           │ RuntimeConstantPool     │
│ #1 Methodref            │           │ #1 MethodRef            │
│    class=#2             │    →      │    method ──────────────┼──→ Method 對象
│    nameAndType=#3       │           │                         │    (內存地址)
│ #2 Class                │           │ #2 ClassRef             │
│    name=#4              │    →      │    class ───────────────┼──→ Class 對象
│ #3 NameAndType          │           │                         │
│    name=#5              │           │                         │
│    descriptor=#6        │           │                         │
│ #4 Utf8 "Calculator"    │           │                         │
│ #5 Utf8 "add"           │           │                         │
│ #6 Utf8 "(II)I"         │           │                         │
└─────────────────────────┘           └─────────────────────────┘
```

* 符號引用：字符串形式的引用（"Calculator", "add", "(II)I"）
* 直接引用：內存中的指針（*Method, *Class）

<br>

---

<br>

## ClassRef (Class 直接引用)

用於 `new`、`checkcast`、`instanceof` 等指令。

```
Class -> RuntimeConstantPool
                   | 
                   └--> * ClassRef
                   └--> * FieldRef
                   └--> * MethodRef
```

<br>

__ClassRef 直接引用__ 指向一個 Class，使用 lazy loading 機制。

JVM 並不會在一開始就完整載入所有 class，先持有一個參考，當真正需要調用到該 Class 時，才會真正使用 ClassLoader 開始載入並緩存到 ClassLoader 中。

<br>
<br>

## FieldRef (Field 直接引用)

__FieldRef 直接引用__ 指向一個 Field，使用 lazy loading 機制。

FieldRef 從 `classfile.ConstantFieldRefInfo` 解析得到 `name` 與 `descriptor`。

當第一次執行 `ResolvedField()` 時，會需要利用 `name` 與 `descriptor` 在所屬的 Class 找尋對應的 Field

<br>
<br>

## MethodRef (MethodRef 直接引用)

__MethodRef 直接引用__ 指向一個 MethodRef，使用 lazy loading 機制。

MethodRef 從 `classfile.ConstantFieldRefInfo` 解析得到 `name` 與 `descriptor`。

當第一次執行 `ResolvedField()` 時，會需要利用 `name` 與 `descriptor` 在所屬的 Class 找尋對應的 Field

<br>

---

<br>

## Class

ClassFile 被 ClassLoader 載入的實例化 Class，被存放在方法區 (ClassLoader) 內。

```
 ClassFile（編譯時）    →    Class（運行時）
 ┌─────────────────┐        ┌─────────────────┐
 │ constantPool    │   →    │ constantPool    │  運行時常量池
 │ accessFlags     │   →    │ accessFlags     │
 │ thisClass       │   →    │ name            │  直接存類名
 │ superClass      │   →    │ superClass      │  指向父類 Class
 │ interfaces      │   →    │ interfaces      │  指向接口 Class[]
 │ fields          │   →    │ fields          │  運行時字段
 │ methods         │   →    │ methods         │  運行時方法
 └─────────────────┘        └─────────────────┘
```

看一下 Class 內完整的內容

```go
type Class struct {
	accessFlags       uint16
	name              string // className (ex: java/lang/Object.java)
	superClassName    string
	interfaceNames    []string
	constantPool      *RuntimeConstantPool // ConstantPool - Runtime
	fields            []*Field
	methods           []*Method
	loader            *ClassLoader // 加載此類的 ClassLoader
	superClass        *Class       // parent class ref
	interfaces        []*Class     // interface refs
	instanceSlotCount uint         // 實例變量佔用的 slot 數量
	staticSlotCount   uint         // 類變量佔用的 slot 數量
	instanceVars      rtcore.Slots // class's non-static vars
	staticVars        rtcore.Slots // class's static vars
}
```

<br>

### Phase - v0.2.4 新增:

1. `NewObject()` 封裝了物件建立邏輯
    - 自動使用 instanceSlotCount
    - 自動傳遞 class 引用給 Object

2. `initStarted` 變量追蹤初始化狀態
    - 確保 <clinit> 只執行一次
    - MVP 簡化：不處理多執行緒競爭

3. `GetField()` 支援繼承查找
    - 先在當前類別找
    - 找不到就往父類找

4. 類型檢查方法為未來 instanceof/checkcast 準備

<br>

**為什麼 Class 需要 NewObject() 方法 ?**

當執行 `new Counter()` 時：

1. `new` 指令從 RuntimeConstantPool 取得 ClassRef
2. 解析得到 Counter 類別的 *Class
3. 需要知道 Counter 物件需要多少個 slots → 這個資訊在 Class.instanceSlotCount 裡
4. 呼叫 class.NewObject() 建立物件

<br>

**Class.NewObject() 的職責：**

- instanceSlotCount（物件需要的欄位數）
- 自動把 class 引用傳給 Object

<br>

**為什麼需要追蹤初始化狀態 ?**

Java 類別有嚴格的初始化規則：

```java
class Counter {                                                
	static int count = 10;      // 靜態變數初始化              
	static {                    // 靜態初始化區塊              
		count = count + 5;                                     
	}                                                          
}   
```

編譯器會產生 <clinit> 方法：

- 初始化 static 變數
- 執行 static {} 區塊

JVM 規範要求：

1. 類別只能初始化一次
2. 初始化必須在以下時機觸發：
    - new 建立物件
    - 存取靜態欄位 (getstatic/putstatic)
    - 呼叫靜態方法 (invokestatic)
    - 子類初始化時，父類要先初始化



<br>

## Field

Class 的 Field 實例，包含在 Class 內存於方法區中。

```go
type Field struct {
	accessFlags     uint16
	name            string
	descriptor      string
	class           *Class // belongs to
	slotId          uint   // index in slot
	constValueIndex uint   // ConstantValue attributes index (for static final) could be found in class's RuntimeConstantPool
}
```

<br>
<br>

## Method

Class 的 Method 實例，包含在 Class 內存於方法區中。

```go
// Method in Class
//
// including:
// - method signature (name & descriptor)
// - access flags
// - bytecode
// - max Stack size
// - max LocalVars table size
// - method input params count (actually is slots count)
type Method struct {
	accessFlags  uint16
	name         string
	descriptor   string
	class        *Class
	maxStack     uint16
	maxLocals    uint16
	code         []byte
	argSlotCount uint
}
```

<br>

比較重要的點 `calcArgSlotCount()`:

* 需要根據 `descriptor` 來計算 argSlotCount。
* 如果該方法是非靜態方法，第一個 argSlot 預設都是 `this`，自動多加一個 slot 數量。

```go
// calcArgSlotCount calculate params take slots count
// based on Descriptor
// ex: (II)V → 2 int → 2 slots
// ex: (DD)V → 2 double → 4 slots (double take 2 slots)
// ex: (JD)V → 1 long + 1 double → 4 slots
// ex: (Ljava/lang/String;I)V → 1 ref + 1 int → 2 slots
func (m *Method) calcArgSlotCount() {
	parsedDescriptor := parseMethodDescriptor(m.descriptor)
	for _, paramType := range parsedDescriptor.parameterTypes {
		m.argSlotCount++
		// long & double take 2 slots
		if paramType == "J" || paramType == "D" {
			m.argSlotCount++
		}
	}

	// non-static method first slot store this(object) reference, so we + 1
	if !m.IsStatic() {
		m.argSlotCount++
	}
}
```

<br>

---

<br>


## MethodDescriptor 方法描述符解析結果

將方法描述符轉化成資料結構

例如：`(IDLjava/lang/String;)V`

```go
type MethodDescriptor struct {
	parameterTypes []string
	returnType     string
}
```

* parameterTypes: ["I", "D", "Ljava/lang/String;"]
* returnType: "V"

### 描述符格式：(參數類型)返回類型

類型編碼：
```
B - byte      C - char      D - double    F - float
I - int       J - long      S - short     Z - boolean
V - void      L類名; - 引用類型    [ - 數組
```

例子：
```
()V                      → void method()
(II)I                    → int method(int, int)
(Ljava/lang/String;)V    → void method(String)
([I)V                    → void method(int[])
([[Ljava/lang/Object;)V  → void method(Object[][])
```

<br>

---

<br>


## `invokestatic` 執行流程圖解

當執行 `invokestatic StaticCall.add` 時：

```
invokestatic #1
      │
      ▼
┌─────────────────────────────────────────────────────────┐
│ INVOKE_STATIC.Execute(frame)                            │
│                                                         │
│   cp := frame.Method().Class().ConstantPool()          │
│   methodRef := cp.GetConstant(1).(*MethodRef)          │
│   method := methodRef.ResolvedMethod()  ◄───────────┐   │
│                                                     │   │
└─────────────────────────────────────────────────────│───┘
                                                      │
      ┌───────────────────────────────────────────────┘
      ▼
┌─────────────────────────────────────────────────────────┐
│ MethodRef.ResolvedMethod()                              │
│                                                         │
│   if r.method == nil {                                 │
│       r.resolveMethodRef()  ◄────────────────────┐      │
│   }                                              │      │
│   return r.method                                │      │
│                                                  │      │
└──────────────────────────────────────────────────│──────┘
                                                   │
      ┌────────────────────────────────────────────┘
      ▼
┌─────────────────────────────────────────────────────────┐
│ MethodRef.resolveMethodRef()                            │
│                                                         │
│   c := r.ResolvedClass()  ◄──────────────────────┐      │
│   method := lookupMethod(c, r.name, r.descriptor)│      │
│   r.method = method                              │      │
│                                                  │      │
└──────────────────────────────────────────────────│──────┘
                                                   │
      ┌────────────────────────────────────────────┘
      ▼
┌─────────────────────────────────────────────────────────┐
│ SymRef.ResolvedClass()                                  │
│                                                         │
│   if r.class == nil {                                  │
│       r.resolveClassRef()  ◄─────────────────────┐      │
│   }                                              │      │
│   return r.class                                 │      │
│                                                  │      │
└──────────────────────────────────────────────────│──────┘
                                                   │
      ┌────────────────────────────────────────────┘
      ▼
┌─────────────────────────────────────────────────────────┐
│ SymRef.resolveClassRef()                                │
│                                                         │
│   d := r.cp.class          // 當前類 (StaticCall)       │
│   loader := d.loader       // 當前類的 ClassLoader      │
│   c := loader.LoadClass(r.className)  // 加載目標類     │
│   r.class = c              // 緩存                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

<br>

## 為什麼用「當前類的 ClassLoader」？

這是 類加載器委託模型（Class Loader Delegation） 的關鍵：

```
god := r.cp.class        // d = 當前正在執行的類
c := d.loader.LoadClass(r.className)  // 用 d 的 loader 加載新類
```

**原因：**

1. **雙親委派模型**：確保相同的類名由相同的 ClassLoader 加載
2. **類型安全**：不同 ClassLoader 加載的同名類是不同的類型
3. **命名空間隔離**：同一個類名在不同 ClassLoader 下可以是不同的類

例如：

```
┌─────────────────────────────────────────────────────────┐
│  StaticCall 類由 AppClassLoader 加載                     │
│  StaticCall 調用 Calculator.add()                       │
│  Calculator 也應該由 AppClassLoader 加載                 │
│  （使用同一個 ClassLoader）                               │
└─────────────────────────────────────────────────────────┘
```
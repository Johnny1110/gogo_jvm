# v0.3.2: Reference 類型 — `java.lang.ref` 套件

<br>

---

<br>

**目標**: 實現 `java.lang.ref` 套件中的引用類型，為 GC 提供精細化的物件存活控制能力。

1. 深入理解 Java 四種引用類型的設計哲學
2. 理解 Reference 類型與 GC 的協作機制
3. 實現 `Reference`, `SoftReference`, `WeakReference`, `PhantomReference`
4. 實現 `ReferenceQueue` 佇列機制
5. 理解為什麼需要不同強度的引用

<br>

---

<br>
<br>

## 原理

<br>

### 為什麼需要 Reference 類型？

在 Java 中，最常見的引用方式是 強引用（Strong Reference）:

```java
Object obj = new Object();  // 強引用
```

只要強引用存在，GC 絕對不會 回收該物件。但這帶來了問題:

<br>

問題場景: **快取（Cache）**

```java
class ImageCache {
    private Map<String, Image> cache = new HashMap<>();
    
    public Image getImage(String path) {
        Image img = cache.get(path);
        if (img == null) {
            img = loadImage(path);
            cache.put(path, img);  // 強引用
        }
        return img;
    }
}
```

問題:

* 快取中的 Image 永遠不會被回收（強引用）
* 記憶體會持續成長，最終拋出 `OutOfMemoryError`

<br>

解決方案: **軟引用快取**

```java
class ImageCache {
    private Map<String, SoftReference<Image>> cache = new HashMap<>();
    
    public Image getImage(String path) {
        SoftReference<Image> ref = cache.get(path);
        Image img = (ref != null) ? ref.get() : null;
        
        if (img == null) {
            img = loadImage(path);
            cache.put(path, new SoftReference<>(img));
        }
        return img;
    }
}
```

效果:

* 記憶體充足時: 快取正常運作
* 記憶體不足時: **GC 會回收軟引用指向的物件，避免 OOM**

<br>

---

<br>
<br>

## 四種引用類型

<br>

### 引用強度階層

<br>

#### 1. Strong Reference（強引用）


```java
Object obj = new Object();
```

* GC 永遠不會回收
* 是 Java 預設的引用方式
* 只有當 obj = null 後，物件才「可能」被回收

<br>

#### Soft Reference（軟引用）

```java
SoftReference<Object> ref = new SoftReference<>(obj);
```

* 記憶體 **不足** 時才會被回收
* 適合用於: 快取（Cache）
* JVM 保證: 在拋出 OOM 之前，會先回收所有軟引用 

<br>

#### Weak Reference（弱引用）

```java
WeakReference<Object> ref = new WeakReference<>(obj);
```

* 下次 GC 時 **一定** 會被回收（不管記憶體是否充足）
* 適合用於: `WeakHashMap`, 監聽器註冊表
* 生命週期: 只存活到下次 GC

<br>

#### Phantom Reference（虛引用）

```java
PhantomReference<Object> ref = new PhantomReference<>(obj, queue);
```

* `get()` 永遠返回 null（無法透過虛引用取得物件）
* 唯一用途: 追蹤物件被回收的 **時機** (就像是 GC Object Event Listener)
* 必須搭配 `ReferenceQueue` 使用
* 適合用於: 資源清理、替代 finalize()


> 我曾在某個影片中聽到過 `PhantomReference` 在 NIO 模組中被大量使用。具體用做什麼其實沒有交代清楚，之後在深挖這一塊知識。

<br>

### 各引用類型比較表

| 引用類型 (Reference) | 回收時機                         | get() 返回值        | 是否必須配合 Queue | 典型應用場景            |
|--------------------|----------------------------------|---------------------|-------------------|-------------------------|
| Strong             | 永不（除非斷開所有引用）         | 物件本身            | 否                | 一般程式設計            |
| Soft               | 記憶體不足時                     | 物件或 `null`       | 可選              | 快取（Cache）           |
| Weak               | 下一次 GC 時                     | 物件或 `null`       | 可選              | `WeakHashMap`           |
| Phantom            | 物件被回收後（finalize 之後）    | 永遠為 `null`       | 必須              | 資源清理、監控回收狀態  |


<br>

---

<br>
<br>

## Reference 類別架構

<br>

### Java 標準類別層次
# v0.3.2: Reference 類型 — `java.lang.ref` 套件

<br>

---

<br>

**目標**: 實現 `java.lang.ref` 套件中的引用類型，為 GC 提供精細化的物件存活控制能力。

1. 深入理解 Java 四種引用類型的設計哲學
2. 理解 Reference 類型與 GC 的協作機制
3. 實現 `Reference`, `SoftReference`, `WeakReference`, `PhantomReference`
4. 實現 `ReferenceQueue` 佇列機制
5. 理解為什麼需要不同強度的引用

<br>

---

<br>
<br>

## 原理

<br>

### 為什麼需要 Reference 類型？

在 Java 中，最常見的引用方式是 強引用（Strong Reference）:

```java
Object obj = new Object();  // 強引用
```

只要強引用存在，GC 絕對不會 回收該物件。但這帶來了問題:

<br>

問題場景: **快取（Cache）**

```java
class ImageCache {
    private Map<String, Image> cache = new HashMap<>();
    
    public Image getImage(String path) {
        Image img = cache.get(path);
        if (img == null) {
            img = loadImage(path);
            cache.put(path, img);  // 強引用
        }
        return img;
    }
}
```

問題:

* 快取中的 Image 永遠不會被回收（強引用）
* 記憶體會持續成長，最終拋出 `OutOfMemoryError`

<br>

解決方案: **軟引用快取**

```java
class ImageCache {
    private Map<String, SoftReference<Image>> cache = new HashMap<>();
    
    public Image getImage(String path) {
        SoftReference<Image> ref = cache.get(path);
        Image img = (ref != null) ? ref.get() : null;
        
        if (img == null) {
            img = loadImage(path);
            cache.put(path, new SoftReference<>(img));
        }
        return img;
    }
}
```

效果:

* 記憶體充足時: 快取正常運作
* 記憶體不足時: **GC 會回收軟引用指向的物件，避免 OOM**

<br>

---

<br>
<br>

## 四種引用類型

<br>

### 引用強度階層

<br>

#### 1. Strong Reference（強引用）


```java
Object obj = new Object();
```

* GC 永遠不會回收
* 是 Java 預設的引用方式
* 只有當 obj = null 後，物件才「可能」被回收

<br>

#### Soft Reference（軟引用）

```java
SoftReference<Object> ref = new SoftReference<>(obj);
```

* 記憶體 **不足** 時才會被回收
* 適合用於: 快取（Cache）
* JVM 保證: 在拋出 OOM 之前，會先回收所有軟引用 

<br>

#### Weak Reference（弱引用）

```java
WeakReference<Object> ref = new WeakReference<>(obj);
```

* 下次 GC 時 **一定** 會被回收（不管記憶體是否充足）
* 適合用於: `WeakHashMap`, 監聽器註冊表
* 生命週期: 只存活到下次 GC

<br>

#### Phantom Reference（虛引用）

```java
PhantomReference<Object> ref = new PhantomReference<>(obj, queue);
```

* `get()` 永遠返回 null（無法透過虛引用取得物件）
* 唯一用途: 追蹤物件被回收的 **時機** (就像是 GC Object Event Listener)
* 必須搭配 `ReferenceQueue` 使用
* 適合用於: 資源清理、替代 finalize()


> 我曾在某個影片中聽到過 `PhantomReference` 在 NIO 模組中被大量使用。具體用做什麼其實沒有交代清楚，之後在深挖這一塊知識。

<br>

### 各引用類型比較表

| 引用類型 (Reference) | 回收時機                         | get() 返回值        | 是否必須配合 Queue | 典型應用場景            |
|--------------------|----------------------------------|---------------------|-------------------|-------------------------|
| Strong             | 永不（除非斷開所有引用）         | 物件本身            | 否                | 一般程式設計            |
| Soft               | 記憶體不足時                     | 物件或 `null`       | 可選              | 快取（Cache）           |
| Weak               | 下一次 GC 時                     | 物件或 `null`       | 可選              | `WeakHashMap`           |
| Phantom            | 物件被回收後（finalize 之後）    | 永遠為 `null`       | 必須              | 資源清理、監控回收狀態  |


<br>

---

<br>
<br>

## Reference 類別架構

<br>

### Java 標準類別層次

```
                    ┌─────────────────────────┐
                    │   java.lang.Object      │
                    └──────────┬──────────────┘
                               │
                    ┌──────────┴──────────────┐
                    │ java.lang.ref.          │
                    │    Reference<T>         │  <- 抽象基類
                    │                         │
                    │  - referent: T          │  <- 被引用的物件
                    │  - queue: ReferenceQueue│
                    │  - next: Reference      │  <- 佇列用鏈結
                    │                         │
                    │  + get(): T             │
                    │  + clear(): void        │
                    │  + enqueue(): boolean   │
                    │  + isEnqueued(): bool   │
                    └──────────┬──────────────┘
                               │
          ┌────────────────────┼────────────────────┐
          │                    │                    │
          ▼                    ▼                    ▼
 ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────┐
 │ SoftReference<T>│  │ WeakReference<T>│  │ PhantomReference<T> │
 └─────────────────┘  └─────────────────┘  └─────────────────────┘
```

<br>
<br>

### ReferenceQueue 的角色

<br>

####  ReferenceQueue 運作機制

**建立時:**

```java
ReferenceQueue<Object> queue = new ReferenceQueue<>();
WeakReference<Object> ref = new WeakReference<>(obj, queue);
```

<br>

```
   GC 前:                              GC 後（obj 被回收）:                
                                                                            
   ┌─────────────┐                     ┌─────────────┐                      
   │ WeakRef     │                     │ WeakRef     │                      
   │ ┌─────────┐ │         ──GC──►     │ ┌─────────┐ │                      
   │ │referent ├─┼─► obj               │ │referent │ │──► null              
   │ └─────────┘ │                     │ └─────────┘ │                      
   │ queue ──────┼─► queue             │ queue ──────┼──► queue             
   └─────────────┘                     └──────┬──────┘                      
                                              │                             
                                              │ enqueue                     
                                              ▼                             
                                       ┌─────────────┐                      
                                       │  Reference  │                      
                                       │   Queue     │                      
                                       │ ┌─────────┐ │                      
                                       │ │  head ──┼─┼──► ref               
                                       │ └─────────┘ │                      
                                       └─────────────┘                      
```

應用程式可以透過 `queue.poll()` 或 `queue.remove()` 取得被回收的引用然後執行清理工作 (釋放相關資源)。

<br>
<br>

### Reference 的生命週期與狀態機

<br>

#### 狀態說明


| 狀態 (State) | referent | queue | 狀態說明 |
|-------------|----------|-------|----------|
| Active      | 非 `null` | 已註冊 | 剛建立，物件仍然存活，尚未被 GC 影響 |
| Pending     | `null`    | 待入佇列 | GC 已清除 referent，等待 Reference Handler 執行 |
| Enqueued    | `null`    | 已在佇列中 | 已加入 ReferenceQueue，等待應用程式處理 |
| Inactive    | `null`    | 已處理完畢 | 最終狀態，不再有任何作用 |

**補充:**

* Active → Pending:

    由 GC 觸發，referent 被清除 (`Soft`/`Weak`/`Phantom`)

* Pending → Enqueued:

    由 JVM 內部的 Reference Handler Thread 放入 ReferenceQueue。
* Enqueued → Inactive:

    由應用程式自行 poll / remove queue 並處理後完成。

<br>

#### Reference 狀態轉換

```
┌────────────────────────────────────────────────────────────────────────────┐
│                      Reference State Machine                               │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│                           ┌────────────────────┐                           │
│                           │    Active          │  ← init STATE             │
│                           │                    │                           │
│                           │ referent != null   │                           │
│                           │ queue = registered │                           │
│                           └───────┬────────────┘                           │
│                                   │                                        │
│              ┌────────────────────┼────────────────────┐                   │
│              │                    │                    │                   │
│              │ clear()            │ GC                 │ GC                │
│              │ (程式主動清除)       │ (有註冊 queue)      │ (無註冊 queue)     │
│              ▼                    ▼                    ▼                   │
│     ┌───────────────┐    ┌───────────────┐    ┌───────────────┐            │
│     │   Inactive    │    │   Pending     │    │   Inactive    │            │
│     │               │    │               │    │               │            │
│     │referent = null│    │referent = null│    │referent = null│            │
│     │(never enquene)│    │ (wait enquene)│    │(never enquene)│            │
│     └───────────────┘    └───────┬───────┘    └───────────────┘            │
│                                  │                                         │
│                                  │ Reference Handler Thread                │
│                                  │ (JVM Inner Thread)                      │
│                                  ▼                                         │
│                         ┌───────────────┐                                  │
│                         │   Enqueued    │                                  │
│                         │               │                                  │
│                         │ in queue &    │                                  │
│                         │ waiting       │                                  │
│                         └───────┬───────┘                                  │
│                                 │                                          │
│                                 │ queue.poll() / remove()                  │
│                                 ▼                                          │
│                        ┌──────────────────┐                                │
│                        │   Inactive       │                                │
│                        │                  │                                │
│                        │removed from queue│                                │
│                        │  life cycle end  │                                │
│                        └──────────────────┘                                │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘
```

<br>

---

<br>
<br>

## Reference 與 GC 的協作

<br>

### GC 標記階段的特殊處理

```
┌────────────────────────────────────────────────────────────────────────────┐
│                    GC Mark Phase - Reference Processing                    │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│   標準 GC 標記（從 GC Roots 開始）:                                           │
│                                                                            │
│   GC Roots                                                                 │
│      │                                                                     │
│      ├──► 強引用 ──► Object A ──► 標記為存活                                  │
│      │                                                                     │
│      └──► SoftRef ─┐                                                       │
│                    │                                                       │
│                    ▼                                                       │
│   ┌─────────────────────────────────────────────────────────────────┐      │
│   │  遇到 Reference 物件時，GC 會特殊處理：                             │      │
│   │                                                                 │      │
│   │  1. Reference 物件本身會被標記（它是從 GC Root 可達的)               │      │
│   │                                                                 │      │
│   │  2. 但 referent 指向的物件需要延遲判斷:                             │      │
│   │     ┌──────────────────────────────────────────────────────┐    │      │
│   │     │  if (referent 只能透過 Reference 可達) {               │    │      │
│   │     │      // 沒有強引用指向它                                │    │      │
│   │     │      根據 Reference 類型決定是否回收 (Soft/Week/Phantom) │   │      │
│   │     │  } else {                                            │    │      │
│   │     │      // 還有其他強引用                                 │    │      │
│   │     │      保持 referent 存活                               │    │      │
│   │     │  }                                                   │    │      │
│   │     └──────────────────────────────────────────────────────┘    │      │
│   └─────────────────────────────────────────────────────────────────┘      │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘
```

<br>
<br>

### GC 處理不同 Reference 類型的策略

<br>

#### Phase 1: Mark

* 標記所有從 GC Roots 強可達的物件
* 遇到 Reference 時，記錄但暫不處理 referent

<br>

#### Phase 2: Process **SoftReferences**

* Heap 空間是否充足:
  * **充足** - 保持 `SoftRef.referent` 存活
  * **不足** - 清除 `SoftRef.referent`，加入 pending list

  > HotSpot 使用 LRU 策略，優先保留最近使用的 SoftRef
  >> 公式: `clock - timestamp > threshold * free_heap_ratio`

<br>

#### Phase 3: Process **WeakReferences**

* 無條件清除所有只被 WeakRef 引用的物件
* `WeakRef.referent = null`
* 加入 pending list

<br>

#### Phase 4: Finalization & **PhantomReferences**

* 執行需要 `finalize()` 的物件 (不建議 Override 該方法，上個章節有提到)
* 處理 PhantomReference:
  * PhantomRef.referent 已被回收
  * 加入 pending list
  * 注意: referent 不會被清成 null (Java 9+ 會)

<br>

#### Phase 5: Sweep

* 回收所有未標記的物件
* Reference Handler Thread 將 pending list 入佇列 (符合上面對於 Ref 狀態機的敘述)

<br>

---

<br>
<br>

## HotSpot JVM 中的實現細節

<br>

### Reference 類別的內部結構（JDK 原始碼簡化）

```java
public abstract class Reference<T> {
    
    // 被引用的物件（GC 會特殊處理這個欄位）
    private T referent;
    
    // 關聯的佇列（可為 null）
    volatile ReferenceQueue<? super T> queue;
    
    // 佇列中的下一個 Reference（鏈結串列結構）
    @SuppressWarnings("rawtypes")
    volatile Reference next;
    
    // GC 發現的、待處理的 Reference 鏈結串列（JVM 內部使用）
    // 這是一個靜態欄位，由 Reference Handler Thread 處理
    private static Reference<Object> pending = null;
    
    // ========================================
    // Core Methods
    // ========================================
    
    // 取得被引用的物件
    public T get() {
        return this.referent;
    }
    
    // 清除引用（程式主動呼叫）
    public void clear() {
        this.referent = null;
    }
    
    // 將此 Reference 加入佇列
    public boolean enqueue() {
        return this.queue.enqueue(this);
    }
    
    // 檢查是否已入佇列
    public boolean isEnqueued() {
        return (this.queue == ReferenceQueue.ENQUEUED);
    }
}
```

<br>
<br>

### Reference Handler Thread

HotSpot JVM 中有一個專門的執行緒 `ReferenceHandler`，負責將 GC 發現的 Reference 加入佇列:


JVM 內部執行緒 (簡化版):
```java
private static class ReferenceHandler extends Thread {
    
    public void run() {
        while (true) {
            Reference<Object> r;
            
            synchronized (lock) {
                // 等待 GC 將 Reference 加入 pending list
                while (pending == null) {
                    lock.wait();
                }
                
                // 取出一個 pending Reference
                r = pending;
                pending = r.discovered;
                r.discovered = null;
            }
            
            // 將 Reference 加入其關聯的 ReferenceQueue
            ReferenceQueue<Object> q = r.queue;
            if (q != ReferenceQueue.NULL) {
                q.enqueue(r);
            }
        }
    }
}
```

<br>

---

<br>
<br>

## GOGO JVM 實現設計

* runtime/heap/
  * reference.go           # Reference 類型定義 
  * reference_queue.go     # ReferenceQueue 實現
  * reference_processor.go # GC 協作的 Reference 處理器

* native/java/lang/ref/
  * reference.go           # Reference Native 方法
  * soft_reference.go      # SoftReference Native 方法
  * weak_reference.go      # WeakReference Native 方法
  * phantom_reference.go   # PhantomReference Native 方法
  * reference_queue.go     # ReferenceQueue Native 方法

<br>

---

<br>
<br>

## 總結

### 為什麼 Java 需要多種引用類型？

記憶體管理的精細化控制

| 需求 | 解決方案（Reference 類型） | 說明 |
|----|--------------------------|------|
| 物件必須存活 | Strong Reference | 只要仍被引用，GC 永遠不會回收 |
| 快取（以記憶體換效能） | Soft Reference | 記憶體吃緊時才會被回收，適合 Cache |
| 不妨礙 GC 的關聯 | Weak Reference | 不影響物件存活，用於輔助關聯關係 |
| 追蹤回收時機 | Phantom Reference | 無法取得物件本體，只用來得知「何時被回收」 |


<br>

### 為什麼 `PhantomReference.get()` 永遠返回 null？

虛引用不是用來「使用」物件的

* 虛引用的唯一目的是 "知道物件何時被回收"
* 如果能取得物件，就可能阻止物件被回收（復活）
* 這違反了 `PhantomReference` 的設計初衷

<br>

### 為什麼需要 `ReferenceQueue`？

非同步通知機制

* GC 是非同步發生的，應用程式無法預知何時發生
* `ReferenceQueue` 提供了一個 "通知管道"
* 應用程式可以監聽這個佇列，在物件被回收後執行清理

<br>

### `Reference` 與 `finalize()` 的比較

| 特性 | finalize() | PhantomReference |
|----|------------|------------------|
| 執行時機 | 物件回收前 | 物件回收後（入佇列時）      |
| 可預測性 | 不可預測 | 相對可預測            |
| 物件復活 | 可能復活 | 不可能復活            |
| 效能影響 | 延遲 GC | 影響較小             |
| Java 9+ 狀態 | 已棄用 | **推薦使用**         |





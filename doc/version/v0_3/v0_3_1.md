# v0.3.1：反射基礎 - Class 物件與 java.lang.Class

<br>

---

<br>

**目標**: 實現 `java.lang.Class` 物件與基本反射功能，讓 Java 程式可以在 Runtime 時期查詢物件的類型資訊。

<br>

---

<br>

## 什麼是反射（Reflection）?

反射是 Java 的一種機制，允許程式在執行時期（Runtime）檢查和操作類別、方法、欄位的資訊。

<br>

編譯時期: 你必須知道類型
```java
String s = new String("hello");
```

執行時期（反射）: 可以動態取得類型資訊
```go
Object obj = getUnknownObject();
Class<?> clazz = obj.getClass();           // 這是什麼類型？
String name = clazz.getName();             // 類別名稱是什麼？
Class<?> parent = clazz.getSuperclass();   // 父類是什麼？
```

<br>
<br>

### 為什麼需要反射?

| 使用場景 | 說明 |
|---------|------|
| 框架開發（Spring、Hibernate） | 需要在執行期動態建立物件、注入依賴（Dependency Injection） |
| 序列化（JSON / XML） | 序列化與反序列化時，需要讀取與操作物件的所有欄位 |
| IDE 功能 | 程式碼補全、重構、跳轉定義等功能，需要分析類別結構與成員 |
| 動態代理 / AOP | 作為 AOP 切面程式設計的基礎，動態攔截與增強方法行為 |
| 測試框架（JUnit） | 需要在執行期找到測試類別與測試方法並自動執行 |
| 外掛系統 | 載入未知或第三方的類別，並在執行期呼叫其方法 |

<br>
<br>

### `java.lang.Class` 的本質

在 Java 中，每個類別在 JVM 中都有一個唯一對應的 Class 物件。這個 Class 物件是 "__類別的類別__" ——它描述了一個類別的所有元資訊。

類別與 Class 物件的關係:

```
                    ┌──────────────────────────────────────┐
                    │             <JVM 記憶體>              │
                    │                                      │
  ┌────────────┐    │   ┌──────────────────────────────┐   │
  │String.java │    │   │   method_area.Class          │   │
  │(sourcecode)│───►│   │   (String class's metadata)  │   │
  └────────────┘    │   │   - name: "java/lang/String" │   │
        │           │   │   - methods: [...]           │   │
        │ javac     │   │   - fields: [...]            │   │
        ▼           │   │   - superClass: Object       │   │
  ┌────────────┐    │   └──────────────┬───────────────┘   │
  │String.class│    │                  │                   │
  │ (bytecode) │───►│                  │ image             │
  └────────────┘    │                  ▼                   │
                    │   ┌────────────────────────────────┐ │
                    │   │   heap.Object                  │ │
                    │   │   (java.lang.Class instance)   │ │
                    │   │   - class: java/lang/Class     │ │
                    │   │   - extra: String's meatadata  │ │
                    │   └────────────────────────────────┘ │
                    │              ▲                       │
                    │              │                       │
                    │   String str = "hello";              │
                    │   str.getClass() 返回這個物件          │
                    │                                      │
                    └──────────────────────────────────────┘
```

<br>
<br>

### 三種取得 Class 物件的方式

<br>

* 1: 透過物件

    ```java
    String s = "hello";
    Class<?> c1 = s.getClass();
    ```
  
* 2: 透過類別字面量

    ```java
    Class<?> c2 = String.class;
    ```
  
* 3: 透過類別名稱（動態載入）

    ```java
    Class<?> c3 = Class.forName("java.lang.String");
    ```

<br>

以上的 `c1`, `c2`, `c3` 實際上是同一個物件:

```java
System.out.println(c1 == c2);  // true
System.out.println(c2 == c3);  // true
```

<br>

---

<br>

## 鏡像（Mirror）設計模式

HotSpot JVM 使用鏡像設計模式來實現反射。這個概念是理解 Class 物件實現的關鍵。

<br>
<br>

### 什麼是鏡像？

<br>

> 每一個 JVM 內部的類別元資料（C++ 結構），
> 都有一個對應的 Java 層面的 Class 物件（Java 物件）。
> 兩者互相指向對方，就像照鏡子一樣。

<br>
<br>

### 鏡像關係圖

<br>

```
┌───────────────────────────────────────────────────────────────┐
│                        JVM Inner                              │
│                                                               │
│   ┌─────────────────────┐         ┌─────────────────────┐     │
│   │ method_area.Class   │◄───────►│ heap.Object         │     │
│   │ (Go struct)         │  image  │ (Java Class Object) │     │
│   │                     │         │                     │     │
│   │ name: "Foo"         │         │ class: Class 元資料  │     │
│   │ methods: [...]      │         │ extra: ──────────┐  │     │
│   │ fields: [...]       │         │                  │  │     │
│   │ jClass: ────────────┼────────►│                  │  │     │
│   │                     │         └──────────────────│──┘     │
│   │                     │◄───────────────────────────┘        │
│   └─────────────────────┘                                     │
│                                                               │
│      JVM 實現者視角                    Java 程式設計師視角        │
│                                     (Using reflaction API)    │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

<br>
<br>

### 為什麼需要鏡像?

<br>

| 問題                       | 解決方案 |
|--------------------------|---------|
| 程式如何存取 JVM 內部資料？            | 透過 `Class` 物件作為「代理人（Proxy）」間接存取 |
| JVM 內部結構如何對 Java 隱藏？     | `Class` 物件只暴露安全且受控的 API |
| 如何確保每個類別只有一個 `Class` 物件？ | 在類別載入（Class Loading）時建立，並由 JVM 快取（Cache） |


<br>
<br>

### GOGO JVM 中的鏡像實現

<br>

```go
// method_area/class.go
type Class struct {
    name       string
    methods    []*Method
    fields     []*Field
    // ... 其他元資料 ...
    
    // v0.3.1 新增：指向 Java 層的 Class 物件
    jClass     *heap.Object    // mirror: Go → Java
}

// heap/object.go  
type Object struct {
    markWord   uint64
    class      interface{}     // 物件的類型（對 Class 物件來說是 java/lang/Class）
    fields     rtcore.Slots
    extra      interface{}     // mirror: Java → Go（存放 *method_area.Class）
}
```

<br>
<br>

### 為什麼用 `extra` 欄位？

<br>

#### 對於普通物件:

* Object.class: 指向該物件的類型（如 String）
* Object.extra: 可能存放陣列元素，字串內容等

#### 對於 Class 物件（特殊）:

* Object.class: `java/lang/Class`（它自己的類型）
* Object.extra: 這個 Class 物件 "__代表__" 的類型（如 String 的元資料）

<br>

---

<br>

## Class 物件的建立時機

<br>

### 類別載入的完整流程（v0.3.1 更新）

```
                        Loading（載入）
                           │
                           ▼
      ┌──────────────────────────────────────────────┐
      │ 1. 讀取 .class 檔案                           │
      │ 2. 解析成 ClassFile 結構                      │
      │ 3. 建立 method_area.Class                    │
      │ 4. v0.3.1 - 建立對應的 java.lang.Class 物件    │ <- 新增
      │ 5. 建立鏡像關係                               │  <- 新增
      └─────────────────────────────────────────────┘
                           │
                           ▼
                      Linking（連結）
                           │
          ┌────────────────┼────────────────┐
          ▼                ▼                ▼
     Verification     Preparation      Resolution
     (驗證)           (準備)           (解析)
     - 檢查格式        - 分配靜態變數    - 符號引用 -(轉)-> 直接引用
     - 檢查語義        - 設定預設值      - 懶加載
                           │
                           ▼
                    Initialization（初始化）
                           │
                           ▼
      ┌─────────────────────────────────────────────┐
      │ 執行 <clinit> 方法                           │
      │ - 靜態變數賦值                                │
      │ - 靜態初始化區塊                              │
      └─────────────────────────────────────────────┘
```

<br>

---

<br>

## 雞生蛋問題（Bootstrap Problem）

<br>

### 問題描述

* 建立 String 的 Class 物件時:
  * classObj.class = `java/lang/Class` 的元資料


* **但是**:
  * `java/lang/Class` 本身也需要一個 Class 物件!
  * `java/lang/Class` 的父類 `java/lang/Object` 也需要 Class 物件!


* 這就形成了循環依賴:
  * 要建立 String.class → 需要先有 Class.class
  * 要建立 Class.class  → 需要先有 Class.class（自己）
  * 要建立 Class.class  → 需要先有 Object.class（父類）
  * 要建立 Object.class → 需要先有 Class.class

<br>

### 解決方案: 兩階段初始化

<br>

#### 階段一: 先建立所有基礎類別的 "__殼__"

```

  ┌──────────────────┐
  │ Load Object      │ → 建立 method_area.Class
  │ (不建立 jClass)   │    jClass = nil（暫時）
  └────────┬─────────┘
           ▼
  ┌──────────────────┐
  │ Load Class       │ → 建立 method_area.Class
  │ (不建立 jClass)   │    jClass = nil（暫時）
  └────────┬─────────┘
           ▼
  ┌──────────────────┐
  │ 其他核心類別...    │
  └────────┬─────────┘
           ▼
  ```

<br>

#### 階段二: 回頭補上所有 Class 物件

```
  ┌──────────────────┐
  │ 為 Object 建立    │ → Object.jClass = new heap.Object{...}
  │ jClass           │
  └────────┬─────────┘
           ▼
  ┌──────────────────┐
  │ 為 Class 建立     │ → Class.jClass = new heap.Object{...}
  │ jClass           │    Class.jClass.class = Class 自己！
  └────────┬─────────┘
           ▼
  ┌──────────────────┐
  │ others...        │
  └──────────────────┘
```

<br>
<br>

### HotSpot 的做法（簡化）

```ccp
void Universe::genesis() {
    // 1. 先建立 java.lang.Object 的 Klass（但沒有 mirror）
    _objectKlass = ...;
    
    // 2. 建立 java.lang.Class 的 Klass（但沒有 mirror）  
    _classKlass = ...;
    
    // 3. 現在可以建立 mirror 了
    // 為 Object 建立 Class 物件
    _objectKlass->set_java_mirror(allocate_mirror(_objectKlass));
    
    // 為 Class 建立 Class 物件
    // 注意：Class 的 mirror 的類型是 Class 自己！
    _classKlass->set_java_mirror(allocate_mirror(_classKlass));
    
    // 4. 建立其他核心類別...
}
```

<br>

---

<br>

## 基本類型的 Class 物件

<br>

### 特殊情況: 基本類型

基本類型也有 Class 物件:

```java
Class<?> intClass = int.class;
Class<?> voidClass = void.class;
```

但是: __基本類型沒有 .class 檔案，沒有方法，沒有欄位，沒有父類。__

<br>
<br>

### 八種基本類型 + void

<br>

| 基本類型 | Class 物件 | getName() 返回值 |
|---------|------------|------------------|
| boolean | boolean.class | "boolean" |
| byte    | byte.class    | "byte" |
| char    | char.class    | "char" |
| short   | short.class   | "short" |
| int     | int.class     | "int" |
| long    | long.class    | "long" |
| float   | float.class   | "float" |
| double  | double.class  | "double" |
| void    | void.class    | "void" |

<br>

* 這些 Class 物件都是由 JVM 內建建立，不是透過 ClassLoader 載入
* 基本型別沒有建構子、欄位或方法，因此反射能力有限
* void.class 主要用於表示方法回傳型別（如 Method.getReturnType()）

<br>

### 基本類型 Class 的特點

```java
int.class.getSuperclass();     // null（沒有父類）
int.class.getInterfaces();     // []（沒有介面）
int.class.getFields();         // []（沒有欄位）
int.class.getMethods();        // []（沒有方法）
int.class.isPrimitive();       // true

// 注意：int.class != Integer.class
int.class == Integer.TYPE;     // true（Integer.TYPE 是 int.class 的別名）
```

<br>

---

<br>

## 陣列類型的 Class 物件

<br>

### 陣列類型的特殊性


陣列也有 Class 物件:

```java
int[] arr = new int[10];
Class<?> c = arr.getClass();

System.out.println(c.getName());           // "[I"
System.out.println(c.getSuperclass());     // class java.lang.Object
System.out.println(c.isArray());           // true
System.out.println(c.getComponentType());  // int
```

<br>
<br>

### 陣列類別名稱的編碼規則

<br>

#### 陣列類別名稱 = `"["` + 元素類型描述符

```
元素類型描述符：

  基本類型：
  
    Z = boolean    B = byte      C = char
    S = short      I = int       J = long
    F = float      D = double
    
  引用類型：
  
    L<className>;

範例：

  int[]        → "[I"
  double[]     → "[D"
  String[]     → "[Ljava/lang/String;"
  int[][]      → "[[I"
  Object[][][] → "[[[Ljava/lang/Object;"
```

<br>
<br>

### 陣列的繼承關係

```
                java.lang.Object
                       │
           ┌───────────┼───────────┐
           │           │           │
      Cloneable   Serializable   所有陣列類型
                                   │
                    ┌──────────────┼──────────────┐
                    │              │              │
                 int[]         String[]      Object[][]
                 "[I"     "[Ljava/lang/String;"  "[[Ljava/lang/Object;"
```

<br>
<br>

### 陣列 Class 的特點

```java
int[].class.getSuperclass();     // java.lang.Object
int[].class.getInterfaces();     // [Cloneable, Serializable]
int[].class.getComponentType();  // int.class

String[].class.getComponentType();  // String.class
int[][].class.getComponentType();   // int[].class（注意！是一維陣列）
```

<br>
<br>

### 動態生成陣列 Class

<br>

陣列類別不需要 .class 檔案，是 JVM 動態生成的。


#### `new int[10];`  執行時:

1. 需要 `"[I"` 這個類別
2. 檢查 ClassLoader 是否已有 → 沒有
3. 動態建立陣列類別:
   * name = `"[I"`
   * superClass = `java.lang.Object`
   * interfaces = `[Cloneable, Serializable]`
   * componentClass = `int`（基本類型）
4. 建立對應的 Class 物件
5. 快取到 ClassLoader

<br>


#### 陣列類別的動態建立

```go
func (loader *ClassLoader) loadArrayClass(name string) *Class {
    // 例如 name = "[I" 或 "[Ljava/lang/String;"
  arrayClass := &Class{
      name:        name,
      accessFlags: ACC_PUBLIC,  // 陣列類別是 public
      loader:      loader,
      superClass:  loader.LoadClass("java/lang/Object"),
      interfaces: []*Class{
          loader.LoadClass("java/lang/Cloneable"),
          loader.LoadClass("java/io/Serializable"),
      },
  }

  // 解析元素類型
  componentClassName := getComponentClassName(name)
  if componentClassName != "" {
      arrayClass.componentClass = loader.LoadClass(componentClassName)
  }

  // 建立 Class 物件
  arrayClass.jClass = loader.createJavaClassObject(arrayClass)
  
  // 快取
  loader.classMap[name] = arrayClass
  
  return arrayClass
}
```

<br>

---

<br>

## `Object.getClass()` 的實現

<br>

### Java 層面

<br>

#### java.lang.Object:

```java 
public class Object {
    public final native Class<?> getClass();
}
```

* `final`: 不能被子類覆寫
* `native`: 由 JVM 原生實現

<br>
<br>

### 執行流程

```
Java 程式碼：

  Object obj = new String("hello");
  Class<?> c = obj.getClass();
  

位元組碼：

  aload_1              // 載入 obj 到棧頂
  invokevirtual #2     // 呼叫 Object.getClass()
  

JVM 執行：

  1. invokevirtual 發現是 native 方法
  2. 調用 objectGetClass native 函數
  3. 從 obj.class（*method_area.Class）取得 jClass
  4. 返回 jClass（*heap.Object）
```

<br>
<br>

### Native 實現

<br>


#### native/java/lang/object.go
```go
func init() {
    runtime.Register("java/lang/Object", "getClass", "()Ljava/lang/Class;", objectGetClass)
}

func objectGetClass(frame *runtime.Frame) {
    // 1. 取得 this 物件
    this := frame.LocalVars().GetThis()
    if this == nil {
        panic("java.lang.NullPointerException")
    }
    
    obj := this.(*heap.Object)
    
    // 2. 取得物件的類別元資料
    class := obj.Class().(*method_area.Class)
    
    // 3. 取得該類別的 Class 物件（鏡像）
    jClass := class.JClass()
    
    // 4. 返回 Class 物件
    frame.OperandStack().PushRef(jClass)
}
```

<br>

---

<br>

## `Class.getName()` 的實現

<br>

### 類別名稱的格式


不同類型的 getName() 返回值
```java
// 普通類別：使用 '.' 分隔
String.class.getName()           // "java.lang.String"
MyClass.class.getName()          // "com.example.MyClass"

// 內部類別：使用 '$' 分隔
Map.Entry.class.getName()        // "java.util.Map$Entry"

// 基本類型：小寫名稱
int.class.getName()              // "int"
void.class.getName()             // "void"

// 陣列類型：JVM 內部格式
int[].class.getName()            // "[I"
String[].class.getName()         // "[Ljava.lang.String;"
int[][].class.getName()          // "[[I"
```

<br>

### 注意：內部名稱 vs 二進制名稱

* JVM 內部使用斜線：`java/lang/String`
* Java API 使用點號：`java.lang.String`


* getName() 需要轉換: 
內部名稱 `"java/lang/String"` → `"java.lang.String"`

<br>

### Native 實現


#### native/java/lang/class.go
```go
func classGetName(frame *runtime.Frame) {
    // 1. 取得 this（java.lang.Class 物件）
    this := frame.LocalVars().GetThis().(*heap.Object)
    
    // 2. 從 extra 取得對應的 method_area.Class
    class := this.Extra().(*method_area.Class)
    
    // 3. 取得類別名稱
    name := class.Name()  // "java/lang/String"
    
    // 4. 轉換格式（斜線 → 點）
    javaName := strings.ReplaceAll(name, "/", ".")  // "java.lang.String"
    
    // 5. 建立 Java String 物件並返回
    jString := heap.InternString(javaName)
    frame.OperandStack().PushRef(jString)
}
```

<br>

---

<br>


## `Class.forName()` 的實現

<br>

### Java 簽名


```java
public static Class<?> forName(String className) throws ClassNotFoundException;

public static Class<?> forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException;
```

<br>
<br>

### 執行流程


```
Class.forName("com.example.MyClass")
```

1. 取得呼叫者的 ClassLoader
2. 使用該 ClassLoader 載入類別
3. 執行類別初始化（`<clinit>`）
4. 返回 Class 物件

<br>

```
Class.forName("com.example.MyClass", false, loader)
```

1. 使用指定的 ClassLoader 載入類別
2. 如果 initialize = false，不執行 `<clinit>`
3. 返回 Class 物件

<br>

### 關於類別初始化

```java
class Foo {
    static {
        System.out.println("Foo initialized!");
    }
}

// 會觸發初始化
Class.forName("Foo");                    // 印出 "Foo initialized!"

// 不會觸發初始化（第二個參數 = false）
Class.forName("Foo", false, loader);     // 不印出

// Foo.class 字面量也不會觸發初始化
Class<?> c = Foo.class;                  // 不印出
```

<br>

---

<br>

## `Class.newInstance()` 的實現（已過時但重要）

<br>

### Java 9+ 已標記為 `@Deprecated`

#### 舊方式（Java 9 前）

```java
Class<?> clazz = Class.forName("com.example.MyClass");
Object obj = clazz.newInstance();  // @Deprecated
```

新方式（Java 9+）

```java
Object obj = clazz.getDeclaredConstructor().newInstance();
```

<br>

### 執行流程

`Class.newInstance()` 等價於：

1. 找到無參建構子
2. 檢查存取權限
3. 建立物件實例（分配記憶體）
4. 呼叫建構子

* 如果類別沒有無參建構子: 拋出 `InstantiationException`

* 如果建構子不可存取: 拋出 `IllegalAccessException`

<br>

---

<br>

## LDC 指令與 Class 常量

<br>

### .class 字面量的編譯結果

```java
// Java 源碼
Class<?> c = String.class;

// 編譯成位元組碼
ldc #2   // 載入 Class 常量
astore_1

// 常量池
#2 = Class  #3    // java/lang/String
#3 = Utf8   java/lang/String
```

<br>

### LDC 指令的擴展（v0.3.1）

```go
// instructions/constants/ldc.go

func (l *LDC) Execute(frame *runtime.Frame) {
    rtcp := frame.Method().Class().ConstantPool()
    c := rtcp.GetConstant(l.Index)
    stack := frame.OperandStack()

    switch val := c.(type) {
    case int32:
        stack.PushInt(val)
    case float32:
        stack.PushFloat(val)
    case string:
        // 字串常量
        stringObj := heap.InternString(val)
        stack.PushRef(stringObj)
        
    // v0.3.1 新增：Class 常量
    case *method_area.ClassRef:
        // 解析 ClassRef 取得 Class
        class := val.ResolvedClass()
        // 取得 Class 物件（鏡像）
        classObj := class.JClass()
        stack.PushRef(classObj)
        
    default:
        panic("unknown constant type")
    }
}
```

# v0.3.0：物件頭重構 (Object Header Revamp)

<br>

---

<br>

**目標：實現標準的物件頭（Object Header），為多執行緒和 GC 打基礎**

1. 深入理解 JVM Object Header 的設計哲學
2. 理解 Mark Word 各欄位的用途與設計巧思
3. 實現 `Object.hashCode()` 的 identity hash code
4. 為後續的 GC (age) 和多執行緒 (lock state) 預留空間
5. 理解為什麼 Mark Word 需要「複用位元」的設計

<br>

---

<br>

## 原理介紹

### Java 物件在記憶體中的真實樣貌

在 HotSpot JVM 中，每個 Java 物件在記憶體中都有固定的布局結構。理解這個結構是理解 GC、同步機制、甚至 JIT 優化的基礎。

**一個普通 Java 物件的記憶體布局**:

```
┌─────────────────────────────────────────────────────────────────┐
│                      Object Layout (64-bit JVM)                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    Object Header                          │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │              Mark Word (8 bytes / 64 bits)          │  │  │
│  │  │  hashCode | age | biased_lock | lock | gc_state ... │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │            Klass Pointer (4 or 8 bytes)             │  │  │
│  │  │            pointing to Class Metadata               │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │      Array Length (4 bytes, only array object)      │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                   Instance Data                           │  │
│  │                   (Object Fields)                         │  │
│  │           ┌──────┬──────┬──────┬──────┐                   │  │
│  │           │field0│field1│field2│ ...  │                   │  │
│  │           └──────┴──────┴──────┴──────┘                   │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                     Padding bytes                         │  │
│  │                  (padding to 8 bytes)                     │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

<br>

### 為什麼需要 Object Header？

如何在不增加額外資料結構的情況下，為每個物件附加 __runtime data__?

這些 __runtime data__ 包括:

| 資訊類型              | 用途說明                     | 使用場景 / 階段                     |
|----------------------|------------------------------|--------------------------------------|
| Identity Hash Code   | 物件的唯一識別碼              | `Object.hashCode()`、`HashMap`       |
| GC Age               | 物件經歷過的 GC 次數          | 分代 GC 的晉升（Promotion）決策      |
| Lock State           | 物件目前的鎖定狀態            | `synchronized` 關鍵字                |
| GC Marking           | 標記物件是否仍然存活          | GC 標記（Mark）階段                  |
| Forwarding Pointer   | 物件搬移後的新記憶體位址      | GC 壓縮（Compact）／複製（Copy）階段 |

<br>

如果為每種資訊都建立獨立的資料結構（例如 Map），會造成:

1. 記憶體開銷: 每個物件都需要額外的 Map Entry
2. 存取效率: 每次存取都要查表
3. GC 複雜度: 這些輔助結構也需要被 GC 管理

解決方案: **將這些資訊內嵌到物件本身 → Object Header**

<br>

---

<br>

## Mark Word — 物件頭的核心

### 設計哲學: 位元複用 (Bit Reuse)

**同一塊記憶體在不同狀態下代表不同含義。**

這是因為:

1. 鎖和 `hashCode` 很少同時需要: 大多數物件從不被 synchronized
2. GC 標記是短暫的: 只在 GC 期間使用
3. 記憶體珍貴: 每個物件都有 header，節省 1 byte = 節省數十億 bytes

<br>

### Mark Word 的狀態機 (64-bit JVM)

<br>

**狀態轉換圖**

```
┌────────────────────────────────────────────────────────────────────────────┐
│                     Mark Word (64 bits) State Transform                    │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        Normal (non-lock) State                      │   │
│  │   ┌─────────┬────────────┬────────┬────────┬────────┐               │   │
│  │   │ unused  │ hashCode   │  age   │ biased │  lock  │               │   │
│  │   │(26 bits)│ (31 bits)  │(4 bits)│ (1 bit)│(2 bits)│               │   │
│  │   │ [63:38] │  [37:7]    │ [6:3]  │  [2]   │ [1:0]  │               │   │
│  │   │    0    │  identity  │  0-15  │   0    │   01   │               │   │
│  │   │         │  hashCode  │        │        │        │               │   │
│  │   └─────────┴────────────┴────────┴────────┴────────┘               │   │
│  │                           lock = 01, biased = 0                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                     │
│                                      │ synchronized(obj)                   │
│                                      ▼                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        Biased Locking State                         │   │
│  │   ┌─────────────────────────┬────────┬────────┬────────┬────────┐   │   │
│  │   │       Thread ID         │ epoch  │  age   │ biased │  lock  │   │   │
│  │   │       (55 bits)         │(2 bits)│(4 bits)│ (1 bit)│(2 bits)│   │   │
│  │   │        [63:9]           │ [8:7]  │ [6:3]  │  [2]   │ [1:0]  │   │   │
│  │   │   Biased Thread ID      │        │        │   1    │   01   │   │   │
│  │   └─────────────────────────┴────────┴────────┴────────┴────────┘   │   │
│  │                        lock = 01, biased = 1                        │   │
│  │                                                                     │   │
│  │                          Applicable when:                           │   │
│  │  An object is used by only one thread (single-thread optimization)  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                     │
│                                      │ Competition has occurred            │
│                                      ▼                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                       Lightweight Locking State                     │   │
│  │  ┌────────────────────────────────────────────────────────┬───────┐ │   │
│  │  │           Lock Record Pointer (62 bits)                │ lock  │ │   │
│  │  │           Pointing to Stack's Lock Record              │(2bits)│ │   │
│  │  │                                                        │  00   │ │   │
│  │  └────────────────────────────────────────────────────────┴───────┘ │   │
│  │                           lock = 00                                 │   │
│  │                                                                     │   │
│  │                          Applicable when:                           │   │
│  │          Brief synchronization blocks use CAS operations 	         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                     │
│                                      │ CAS Failed / Long Term Hold         │
│                                      ▼                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        Heavyweight Locking State                    │   │
│  │  ┌────────────────────────────────────────────────────────┬───────┐ │   │
│  │  │              Monitor Pointer (62 bits)                 │ lock  │ │   │
│  │  │          Pointing to ObjectMonitor structure           │(2bits)│ │   │
│  │  │                                                        │  10   │ │   │
│  │  └────────────────────────────────────────────────────────┴───────┘ │   │
│  │                           lock = 10                                 │   │
│  │                                                                     │   │
│  │                          Applicable when:                           │   │
│  │             Read Thread Compudation, need OS level mutex            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                     │
│                                      │ GC Mark Phase                       │
│                                      ▼                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                            GC Marked State                          │   │
│  │  ┌────────────────────────────────────────────────────────┬───────┐ │   │
│  │  │              GC Information (62 bits)                  │ lock  │ │   │
│  │  │           Forwarding Pointer / Marked Info             │(2bits)│ │   │
│  │  │                                                        │  11   │ │   │
│  │  └────────────────────────────────────────────────────────┴───────┘ │   │
│  │                           lock = 11                                 │   │
│  │                                                                     │   │
│  │                          Applicable when:                           │   │
│  │   During GC, store forwarding pointers or marked information        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘
```

<br>

### 狀態識別：最低 2-3 bits 

JVM 使用最低的 **2-3 bits** 來識別 Mark Word 當前處於哪種狀態: 

| lock bits | biased bit | 狀態              | 說明                                          |
|-----------|------------|-------------------|---------------------------------------------|
| `01`        | `0`          | Normal            | 正常狀態，存放 identity hashCode 與 GC age          |
| `01`        | `1`          | Biased Lock       | 偏向鎖，存放 Thread ID                            |
| `00`        | -          | Lightweight Lock  | 輕量級鎖，存放 Lock Record 指標（Stack）               |
| `10`        | -          | Heavyweight Lock  | 重量級鎖，存放 ObjectMonitor 指標                    |
| `11`        | -          | GC Marked         | GC 標記狀態，存放 Forwarding Pointer 或 Marked Info |


<br>

**為什麼用最低位?**

因為物件地址一定是 8 bytes 對齊的，指標的最低 3 bits 恆為 0，可以 "借用" 來存放狀態標記。

<br>

---

<br>

## Identity Hash Code — 物件的身分證號

### 什麼是 Identity Hash Code？

當呼叫 `Object.hashCode()` 且該類別沒有 override 時，JVM 會返回物件的 identity hash code。

```
int hash = new Object().hashCode(); // identity hash code
```

**hashCode 特性**:

1. 唯一性（近似）: 同一時刻不同物件的 hash code 幾乎不會相同
2. 不變性: 物件存活期間，hash code 不會改變
3. 與記憶體地址無關: 即使 GC 移動物件，hash code 也不變

<br>

### 為什麼不直接用記憶體地址?

早期的 JVM（甚至某些教科書）說 "hashCode 返回的是記憶體地址"，這是錯誤的。

原因:

1. **GC 會移動物件**: Copying GC / Compacting GC 會改變物件地址
2. **Hash 必須不變**: HashMap 依賴 hash code 不變性
3. **地址空間有限**: 64-bit 地址太大，31-bit hashCode 更實用

正確解答: __hashCode 是首次呼叫時生成隨機數，然後存入 Mark Word__

<br>

### HotSpot 的 Hash Code 生成策略

HotSpot 支援多種 hash code 生成策略（可透過 `-XX:hashCode=N` 設定）:

| N | 策略名稱                             | 說明                        |
|---|----------------------------------|---------------------------|
| `0` | Park-Miller RNG                  | 基於全域隨機數生成器                |
| `1` | Address + Random Mix             | 物件位址與隨機數混合                |
| `2` | Constant (= 1)                   | 測試用途，所有物件 hash 相同         |
| `3` | Incremental Counter              | 遞增序號，簡單計數器                |
| `4` | Raw Object Address               | 直接使用物件位址（位址可能因 GC 改變）     |
| `5` | Marsaglia XorShift (**Default**) | **預設**策略，Thread-local RNG |

<br>

**預設策略 (hashCode=5) 的實現:**

```go
// HotSpot source code (簡化版)
static inline int get_next_hash(Thread* self, oop obj) {
    unsigned t = self->_hashStateX;
    t ^= (t << 11);
    self->_hashStateX = self->_hashStateY;
    self->_hashStateY = self->_hashStateZ;
    self->_hashStateZ = self->_hashStateW;
    unsigned v = self->_hashStateW;
    v = (v ^ (v >> 19)) ^ (t ^ (t >> 8));
    self->_hashStateW = v;
    return v & 0x7FFFFFFF;  // 確保為正數（31 bits）
}
```

**為什麼用 XorShift?**

1. 速度快: 只需位元運算，無乘除法
2. Thread-Local: 每個執行緒有自己的狀態，無競爭
3. 分佈均勻: 統計特性良好

<br>

---

<br>

## GC Age — 分代收集的關鍵

### 分代假說 (Generational Hypothesis)


**GC 領域最重要的經驗法則:**

> 大多數物件在創建後很快就會死亡（朝生夕滅），而熬過多次 GC 的物件往往能繼續存活很長時間。

基於此假說，JVM 將 Heap 分為:

* Young Generation: 新物件誕生地，頻繁 GC（__Minor GC__）
* Old Generation: 長壽物件的歸宿，偶爾 GC（__Major GC__）

<br>

### Age 的作用：晉升決策

**物件的一生:**

```
  創建 → Eden 區
          │
          │ Minor GC (存活)
          ▼
       Survivor 區 (age = 1)
          │
          │ Minor GC (存活)
          ▼
       Survivor 區 (age = 2)
          │
          │ ... 反覆 GC ...
          ▼
       age >= 閾值 (預設 15)
          │
          │ 晉升
          ▼
       Old Generation
```

**為什麼是 4 bits (最大 15)?**

經驗法則: 存活超過 15 次 GC 的物件，幾乎都是長壽物件
節省空間: 4 bits 足夠，不需要更多

<br>

---

<br>

## 鎖狀態 — synchronized 的實現基礎

### 為什麼鎖資訊要放在物件頭?

Java 的 `synchronized` 是基於物件的:

```java
synchronized (obj) {
    // 臨界區
}
```

__每個物件都可以作為鎖，因此鎖狀態必須存放在物件本身。__


<br>

### 鎖升級過程（Lock Escalation）

JVM 對鎖進行了精細的優化，從 "__樂觀__" 到 "__悲觀__" 逐步升級:

```
無鎖狀態 (Normal)
    │
    │ 第一次 synchronized
    ▼
偏向鎖 (Biased Locking)
    │  • 記錄偏向的 Thread ID
    │  • 如果總是同一執行緒，只需檢查 ID
    │  • 幾乎零成本
    │
    │ 另一執行緒嘗試獲取
    ▼
輕量級鎖 (Lightweight Lock)
    │  • Mark Word 存放 Lock Record 指標
    │  • 使用 CAS 操作嘗試獲取鎖
    │  • 適合短暫的同步區塊
    │
    │ CAS 自旋失敗多次 / 長時間持有
    ▼
重量級鎖 (Heavyweight Lock)
       • Mark Word 存放 Monitor 指標
       • 需要 OS mutex，執行緒會阻塞
       • 最慢，但保證公平性
```

為什麼要這樣設計?

* 大多數鎖只被一個執行緒使用 → 偏向鎖優化(幾乎無成本)
* 競爭通常很短暫 → 輕量級鎖 + 自旋
* 真正的競爭很少 → 才升級到重量級

<br>

---

<br>

## 在本階段，我們主要關注

* Mark Word 結構
* Identity Hash Code
* GC Age (預留欄位，v0.5.x 使用)
* Lock State (預留欄位，v0.4.x 使用)
* Biased Lock

<br>

---

<br>

## Mark Word 位元布局設計

## 我們採用簡化但相容的設計:


GOGO JVM Mark Word (64 bits):
```
┌─────────────────────────────────────────────────────────────────────┐
│  Bit Position                                                       │
│  63                              32 31                            0 │
├─────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────┬──────────────────────────────────┐ │
│  │         Unused              │         Hash Code                │ │
│  │         (25 bits)           │         (31 bits)                │ │
│  │         [63:39]             │         [38:8]                   │ │
│  └─────────────────────────────┴──────────────────────────────────┘ │
│  ┌───────────┬───────────┬───────────────────────────────────────┐  │
│  │    Age    │  Biased   │           Lock State                  │  │
│  │  (4 bits) │  (1 bit)  │           (3 bits)                    │  │
│  │   [7:4]   │   [3]     │           [2:0]                       │  │
│  └───────────┴───────────┴───────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```
Lock State 編碼:

* `001 (0x1)` = Unlocked (無鎖，Normal 狀態)
* `000 (0x0)` = Light Locked (輕量級鎖)
* `010 (0x2)` = Heavy Locked (重量級鎖)
* `011 (0x3)` = GC Marked (GC 標記)
* `101 (0x5)` = Biased (偏向鎖，biased bit = 1)


<br>

---


<br>

## Test Case


### Basic

```java
public class TestHashCode {
    public static void main(String[] args) {
        Object obj1 = new Object();
        Object obj2 = new Object();
        
        int hash1 = obj1.hashCode();
        int hash2 = obj2.hashCode();
        int hash1Again = obj1.hashCode();
        
        // hash1 應該等於 hash1Again
        if (hash1 == hash1Again) {
            System.out.println(1);  // 輸出 1
        }
        
        // hash1 應該（很大機率）不等於 hash2
        if (hash1 != hash2) {
            System.out.println(2);  // 輸出 2
        }
        
        // hashCode 應該是正數
        if (hash1 > 0 && hash2 > 0) {
            System.out.println(3);  // 輸出 3
        }
        
        System.out.println(99);
    }
}
```

<br>

### `String.hashCode()` vs `Object.hashCode()`

```java
public class TestStringHash {
    public static void main(String[] args) {
        String s1 = new String("hello");
        String s2 = new String("hello");
        
        // String override hashCode()，相同內容應該相同
        if (s1.hashCode() == s2.hashCode()) {
            System.out.println(1);  // 應輸出 1
        }
        
        // 但它們是不同的物件
        if (s1 != s2) {
            System.out.println(2);  // 應輸出 2
        }
        
        // identity hash code 應該不同
        // 注意：System.identityHashCode() 需要 native 支援
        System.out.println(99);
    }
}
```

<br>

---

<br>

## 實現清單

### 新增

* runtime/heap/mark_word.go: Mark Word 常數定義與操作方法
* runtime/heap/hash_generator.go: Identity Hash Code 生成器

### 修改

* runtime/heap/object.go: 新增 markWord 欄位，修改 `NewObject()`
* native/java/lang/object.go: 實現 `objectHashCode()`

<br>

---

<br>

## 總結

### 為什麼 Mark Word 要如此複雜?

**空間效率 + 時間效率的平衡**

* 每個物件都有 header，節省 1 byte = 節省數十億 bytes
* 鎖狀態直接讀取，無需查表
* 位元複用讓不同功能共享同一塊記憶體

### 為什麼用 CAS 操作?

**無鎖並發**

* 多執行緒可能同時修改 Mark Word
* CAS 確保原子性，避免使用 mutex
* 失敗時重試，保證最終一致

### 為什麼 hashCode 只有 31 bits?

**確保為正數**

* Java 的 hashCode() 返回 int，但習慣上期望為正數
* 使用 31 bits + sign bit = 0，確保恆為正數
* HashMap 的 bucket 計算依賴此特性

### 為什麼預設不啟用偏向鎖?

**現代應用場景變化**

* Java 15 開始，偏向鎖預設關閉
* 現代應用多為多執行緒，偏向鎖反而成為負擔
* 撤銷偏向鎖需要 STW，代價高昂

<br>
<br>

### 參考資料

[OpenJDK HotSpot markWord.hpp](https://github.com/openjdk/jdk/blob/master/src/hotspot/share/oops/markWord.hpp)
[JEP 374: Deprecate and Disable Biased Locking](https://openjdk.org/jeps/374)
[The Java® Virtual Machine Specification - Object Creation](https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-2.html#jvms-2.7)
[Marsaglia, "Xorshift RNGs"](https://www.jstatsoft.org/article/view/v008i14)











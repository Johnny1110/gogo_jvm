# v0.3.3：Object 生命週期  (Object Lifecycle)

<br>

---

<br>

**目標**：完善物件從創建到回收的完整生命週期

1. 深入理解 `java.lang.Object` 的核心方法設計哲學
2. 理解 `equals()` 與 `hashCode()` 的契約關係
3. 理解 `clone()` 機制與 `Cloneable` 介面的設計
4. 理解 `finalize()` 機制及其在現代 Java 中的地位
5. 為後續 GC 實現打下基礎

<br>

---

<br>

## 原理介紹

<br>

### Object 類 — Java 的根本

`java.lang.Object` 是所有 Java 類別的根類別。它定義了每個 Java 物件都必須具備的基本行為:

```java
public class Object {
    // 身份識別
    public native int hashCode();
    public boolean equals(Object obj);
    
    // 物件複製
    protected native Object clone() throws CloneNotSupportedException;
    
    // 物件終結
    protected void finalize() throws Throwable;
    
    // 執行緒同步 (v0.4.x)
    public final native void wait(...);
    public final native void notify();
    public final native void notifyAll();
    
    // 反射 (v0.3.1 已實現)
    public final native Class<?> getClass();
    
    // 字串表示
    public String toString();
}
```

<br>

### 為什麼這些方法在 Object 中？

| 方法 | 為什麼定義在 Object | 核心設計理由 |
|----|----|----|
| `hashCode()` | 每個物件都可能被放入 `HashMap` / `HashSet` | 所有物件都必須具備可雜湊的基本能力，支援通用集合框架 |
| `equals(Object)` | 每個物件都需要定義「相等」的語義 | 區分 identity 與 logical equality，支援多型與集合操作 |
| `clone()` | 物件複製是通用需求（但設計具爭議） | JVM 層級只認得「物件複製」，無法由子類自行定義基礎機制 |
| `finalize()` | 資源清理的最後防線（已過時） | 早期 Java 缺乏資源管理機制，作為 GC 時的保底設計 |
| `getClass()` | 提供執行時期類型資訊 | 反射、動態代理、框架運作的基礎 |
| `wait()` / `notify()` / `notifyAll()` | 任何物件都可以作為 Monitor | JVM 的 monitor 與物件本身綁定，同步機制必須對所有物件成立 |

<br>

---

<br>


## Part 1：`equals()` — 物件相等性

<br>

### 兩種相等的概念

1. 引用相等 (Reference Equality) 
    
    ```java
    a == b
    ```

   * 比較的是記憶體位址
   * `a` 和 `b` 是否指向同一個物件

<br>

2. 值相等 (Value Equality)

    ```java
    a.equals(b)
    ```
   
   * 比較的是物件內容
   * `a` 和 `b` 的狀態是否相同？

<br>
<br>

### Object.equals() 的預設實現

```java
// java.lang.Object
public boolean equals(Object obj) {
    return (this == obj);  // 預設：引用相等
}
```

預設行為就是比較引用，與 `==` 完全相同。

<br>
<br>

### `equals()` 的契約 (Contract)

__Java 語言規範定義了 equals() 必須滿足的數學性質__:

| 契約項目 | 名稱（英文） | 規則描述 | 白話說明 |
|----|----|----|----|
| 1 | 自反性 (Reflexive) | `x.equals(x)` 必須返回 `true` | 物件一定要等於自己 |
| 2 | 對稱性 (Symmetric) | 若 `x.equals(y) == true`，則 `y.equals(x)` 也必須為 `true` | 如果 A 等於 B，那 B 也必須等於 A |
| 3 | 傳遞性 (Transitive) | 若 `x.equals(y)` 且 `y.equals(z)`，則 `x.equals(z)` 必須為 `true` | 如果 A = B、B = C，那 A 必須等於 C |
| 4 | 一致性 (Consistent) | 多次呼叫 `x.equals(y)` 必須回傳相同結果（前提是物件狀態未變） | 相等性判斷不能有隨機性 |
| 5 | 非空性 (Non-null) | `x.equals(null)` 必須返回 `false` | 任何物件都不等於 `null` |

<br>

---

<br>

## Part 2：`hashCode()` — 物件的雜湊碼

<br>

### `hashCode()` 的用途

`hashCode()` 主要用於 __雜湊表（HashMap、HashSet）的快速查找__ :

```
┌─────────────────────────────────────────────────────────────────┐
│                   HashMap Inner Structure                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  bucket[0]  ──► [Entry] ──► [Entry] ──► null                    │
│  bucket[1]  ──► null                                            │
│  bucket[2]  ──► [Entry] ──► null                                │
│  bucket[3]  ──► [Entry] ──► [Entry] ──► [Entry] ──► null        │
│  ...                                                            │
│  bucket[n]  ──► [Entry] ──► null                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 查找流程:

1. 計算 `key.hashCode()`
2. 根據 `hashCode` 定位 bucket: `bucket[hashCode % n]` (像是 mysql table 分片設計用id除分片數量的餘數定位 cluster)
3. 在 bucket 的鏈結串列中用 `equals()` 找到目標

<br>

### `hashCode()` 的契約

| 契約項目 | 規則名稱 | 規則描述 | 白話說明 |
|----|----|----|----|
| 1 | 一致性 (Consistent) | 同一物件多次呼叫 `hashCode()` 必須返回相同值（前提是 `equals()` 比較用的狀態未被修改） | 同一個物件，在狀態不變時 hashCode 不可改變 |
| 2 | equals 相容性（最重要） | 若 `a.equals(b) == true`，則 `a.hashCode() == b.hashCode()` 必須成立 | 相等的物件一定要有相同的 hashCode |
| 3 | 不相等物件的 hashCode | 若 `a.equals(b) == false`，則 `a.hashCode() != b.hashCode()` **不是必須** | 不相等的物件可以發生 hash 碰撞，但應盡量避免以提升效能 |

<br>

### `equals()` 與 `hashCode()` 的關係

* `equals() == true`: hashCode() 必須相同 (契約要求)
* `hashCode()` 相同: `equals()` 不一定 true (可能碰撞)
* `hashCode()` 不同:  `equals()` 一定是 false

<br>

---

<br>

## Part 3：`clone()` — 物件複製

<br>

### `clone()` 的設計意圖

`clone()` 提供了一種快速複製物件的機制，比手動建立新物件並複製欄位更有效率: 

手動複製（繁瑣）:

```java
Person copy = new Person();
copy.setName(original.getName());
copy.setAge(original.getAge());
copy.setAddress(original.getAddress());
// ... others            
```

使用 clone()（簡潔）: 

```java
Person copy = (Person) original.clone();
```

<br>

### Cloneable 介面 — 標記介面

```java
// java.lang.Cloneable
public interface Cloneable {
    // empty, no any method.
}
```

`Cloneable` 是一個 **標記介面** (Marker Interface): 

* 不定義任何方法
* 僅作為 "標記"" 告訴 JVM: __這個類別允許被 clone__
* 如果未實現 `Cloneable` 就呼叫 `clone()`，會拋出 `CloneNotSupportedException`

<br>
<br>

### 為什麼 `clone()` 在 Object 中是 protected？

#### `clone()` 的訪問控制

在 Object 類中的 clone 本地方法聲明：

```java
protected native Object clone() throws CloneNotSupportedException;
```

<br>

#### 為什麼是 protected？ 

1. 防止外部隨意複製任何物件
2. 強制子類別  *選擇性加入* (opt-in) clone 功能
3. 子類別必須顯式 override 並改為 public 才能讓外部使用

典型的 override 模式:

```java
public class MyClass implements Cloneable {

   @Override
   public Object clone() throws CloneNotSupportedException {
	   return super.clone();
   }
} 
```

<br>
<br>

### 淺複製 vs 深複製

這個過於簡單，這裡就不展開解釋了，可以參考外部資源: [link](https://blog.csdn.net/adparking/article/details/117225722)


<br>
<br>

### `Object.clone()` 的預設行為

`Object.clone()` *預設是淺複製*

JVM 的 `clone()` native 實現做了什麼:

* 分配與原物件相同大小的記憶體
* 逐位元複製原物件的所有欄位到新物件
  * 基本類型 (int, double, etc.): 值被複製
  * 引用類型 (Object): 引用被複製（指向同一物件）
* 返回新物件的引用

<br>

### `clone()` 的契約

| 契約項目 | 規則描述 | 白話說明 | 備註 |
|----|----|----|----|
| 1 | `x.clone() != x` | clone 必須產生一個新的物件，而不是回傳原物件 | 必須成立 |
| 2 | `x.clone().getClass() == x.getClass()` | clone 的實際執行期類型應與原物件相同 | 非強制，但**強烈建議** |
| 3 | `x.clone().equals(x)` | clone 與原物件在邏輯上應該相等 | 非強制，取決於 `equals()` 的定義 |


<br>

### Joshua Bloch（Effective Java 作者）認為 clone() 設計有問題:

1. 違反直覺的設計
   * `clone()` 在 Object 中，但需要 `Cloneable` 介面
   * `Cloneable` 是空介面，不定義 `clone()` 方法
   * `clone()` 返回 Object，需要強制轉型

2. 淺複製的陷阱
   * 預設淺複製容易造成 "意外共享" 的 bug
   * 深複製需要手動實現，繁瑣且容易出錯

3. 繼承的問題
   * 子類別 clone() 必須呼叫 super.clone()
   * 如果父類別沒有正確實現，子類別會出問題

<br>

推薦的替代方案:

* 複製建構子: `public MyClass(MyClass other) { ... }`
* 靜態工廠方法: `public static MyClass copy(MyClass other)`

<br>
<br>

---

<br>

## Part 4：`finalize()` — 物件終結

<br>

### `finalize()` 的設計意圖

<br>

#### `finalize()` 的原始目的

*提供一個 "最後機會" 讓物件在被 GC 回收前釋放資源*

典型場景:

* 關閉檔案句柄 (file handles)
* 釋放 native 記憶體
* 關閉網路連線
* 釋放資料庫連線

```java
protected void finalize() throws Throwable {
   try {
	   // 清理資源
	   closeNativeResource();
   } finally {
      super.finalize();  // 呼叫父類的 finalizer
   }
}     
```

<br>

#### Finalization 的完整生命週期

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                   Finalizable 物件的生命週期                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────┐                                                            │
│  │ 物件創建     │                                                            │
│  │ new Object()│                                                            │
│  └──────┬──────┘                                                            │
│         │                                                                   │
│         │ JVM 檢測到類別有非空的 finalize() 方法                                │
│         │                                                                   │
│         ▼                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                 註冊到 Finalizer 系統                                │     │
│  │  JVM 內部建立一個 Finalizer 物件包裝此物件                              │     │
│  │  Finalizer 物件持有對原物件的引用                                       │    │
│  └──────┬──────────────────────────────────────────────────────────────┘    │
│         │                                                                   │
│         │ 物件正常使用中...                                                   │
│         │                                                                   │
│         ▼                                                                   │
│  ┌─────────────┐                                                            │
│  │ GC 發現物件  │                                                            │
│  │ 不可達       │ （除了 Finalizer 的引用）                                   │
│  └──────┬──────┘                                                            │
│         │                                                                   │
│         │ 注意：此時物件還不能被回收！                                           │
│         │                                                                   │
│         ▼                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │              放入 Finalization Queue                                 │    │
│  │  物件被加入待處理佇列，等待 Finalizer Thread 執行                        │    │
│  └──────┬──────────────────────────────────────────────────────────────┘    │
│         │                                                                   │
│         │ Finalizer Thread（低優先權背景執行緒，不會即時執行）                    │
│         │                                                                   │
│         ▼                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │              執行 finalize() 方法                                    │    │
│  │                                                                     │    │
│  │  三種可能結果：                                                       │    │
│  │  ┌──────────────┬─────────────────┬──────────────────┐              │    │
│  │  │ 正常結束      │   拋出異常       │    物件復活        │              │    │
│  │  │              │   (被忽略)       │                  │              │    │
│  │  └───────┬──────┴────────┬────────┴─────────┬────────┘              │    │
│  └──────────┼───────────────┼──────────────────┼───────────────────────┘    │
│             │               │                  │                            │
│             ▼               ▼                  ▼                            │
│       ┌──────────┐    ┌──────────┐       ┌──────────────┐                   │
│       │ 標記為    │    │ 標記為    │       │ 物件重新變成   │                   │
│       │ Finalized│    │ Finalized│       │ 強可達        │                   │
│       └────┬─────┘    └────┬─────┘       └──────┬───────┘                   │
│            │               │                    │                           │
│            │               │                    │ 再次變成不可達時             │
│            ▼               ▼                    │ finalize() 不會再次執行！   │
│       ┌───────────────────────┐                 ▼                           │
│       │ 下次 GC 時被回收        │           ┌───────────────┐                 │
│       └───────────────────────┘           │ 直接被回收      │                 │
│                                           │ (已 finalized) │                │
│                                           └───────────────┘                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

*重要: 物件如果因為 finalize() 復活過來，那他將失去這個僅有的復活機會，下次該被 GC 時一定會被 GC*


<br>
<br>

### 物件復活 (Object Resurrection)

```java
public class ResurrectionDemo {
    private static ResurrectionDemo savedReference;
    
    @Override
    protected void finalize() throws Throwable {
        System.out.println("finalize() 被呼叫");
        // 物件復活！將 this 賦值給 static 欄位
        savedReference = this;
    }
    
    public static void main(String[] args) throws Exception {
        ResurrectionDemo obj = new ResurrectionDemo();
        obj = null;  // 使物件可被 GC
        
        System.gc();
        Thread.sleep(1000);
        
        // 物件復活了！
        System.out.println(savedReference);  // 不是 null
        
        // 再次使其不可達
        savedReference = null;
        System.gc();
        Thread.sleep(1000);
        
        // 這次 finalize() 不會再被呼叫
        // 因為每個物件的 finalize() 只會執行一次
    }
}
```

<br>

### `finalize()` 的嚴重問題

| 問題類型 | 問題描述 | 詳細說明 |
|----|----|----|
| 1 | 不可預測的執行時機 | - GC 時機不確定，`finalize()` 執行時機也不確定<br>- 可能造成資源耗盡（如檔案句柄用完）<br>- 在記憶體充足時，可能很久才會 GC |
| 2 | 效能問題 | - 有 `finalize()` 的物件至少需要兩次 GC 才能回收<br>- 需要維護 Finalization Queue<br>- Finalizer Thread 可能成為瓶頸 |
| 3 | 執行緒安全問題 | - `finalize()` 在不確定的執行緒中執行<br>- 可能與應用程式執行緒競爭<br>- 容易造成死鎖 |
| 4 | 異常被忽略 | - `finalize()` 中拋出的異常會被靜默忽略<br>- 可能導致資源洩漏而不自知 |
| 5 | 安全問題 | - Finalizer Attack：惡意子類別可以在 `finalize()` 中復活半初始化的物件，繞過安全檢查 |

<br>
<br>

### Java 9+ 的演進

| 時期 | 版本 / JEP | 說明 | 備註 / 替代方案 |
|----|----|----|----|
| 1996 | Java 1.0 | `finalize()` 被引入 | 初期用於資源釋放，作為 GC 的保底機制 |
| 2017 | Java 9 | 標記 `@Deprecated` | 開始警告開發者不要使用 |
| 2022 | Java 18 - JEP 421 | 標記 `@Deprecated(forRemoval=true)` | 表示將來可能完全移除 |
| 未來 | Future Java | 可能完全移除 `finalize()` | **推薦替代方案**：<br>1. `try-with-resources` + `AutoCloseable`<br>2. `java.lang.ref.Cleaner` (使用 PhantomReference，更可控) |

<br>
<br>

---

<br>

## GOGO JVM 實現設計

* Object.hashCode(): v0.3.0 已實現 identity hash code
* Object.equals(): 預設實現只需比較引用
* Object.clone(): 需處理 Cloneable 檢查、淺複製邏輯
* Object.finalize(): 需實現 Finalization Queue 機制 (v0.5.x 才會實現完整 GC，這裡做一個簡化的框架)

<br>
<br>

---

<br>

## 總結

### 為什麼 equals() 和 hashCode() 必須一起 override？

#### HashMap 的正確性依賴於此契約

* hashCode() 決定物件放在哪個 bucket
* equals() 在 bucket 內部做精確比較
* 如果 equals() 相等但 hashCode() 不同，物件會被放入錯誤的 bucket

<br>

### 為什麼 clone() 的設計被認為有問題？

違反了 Java 的一般設計原則

* 介面應該定義行為（方法），但 Cloneable 是空的
* protected 方法需要 override 才能使用，增加了複雜性
* 淺複製 vs 深複製的選擇被隱藏，容易造成 bug

<br>

### 為什麼 finalize() 被廢棄？

不可預測性和效能問題

* GC 時機不確定 → finalize() 執行時機不確定
* 需要兩次 GC 才能回收物件
* 可能導致資源耗盡（稀缺資源等待 finalize 釋放）
* Finalizer Thread 可能成為瓶頸

<br>

---

<br>

## 參考資料

* [Java Language Specification - Object](https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html#jls-4.3.2)
* [JEP 421: Deprecate Finalization for Removal](https://openjdk.org/jeps/421)
* [Effective Java, 3rd Edition - Item 11: Always override hashCode when you override equals](https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/)
* [Effective Java, 3rd Edition - Item 13: Override clone judiciously](https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/)
* [Oracle: How to Handle Java Finalization's Memory-Retention Issues](https://www.oracle.com/technical-resources/articles/javase/finalization.html)
# v0.4.2：wait / notify 機制

<br>

---

<br>

**目標**：實現執行緒間的協調通訊

**需要實現的方法**：

| 方法 | 說明 |
|------|------|
| `Object.wait()` | 釋放鎖並等待 |
| `Object.wait(long)` | 帶超時的等待 |
| `Object.notify()` | 喚醒一個等待的執行緒 |
| `Object.notifyAll()` | 喚醒所有等待的執行緒 |

<br>

**wait / notify 流程**：

```
  Thread A                          Thread B
     │                                 │
     │ synchronized(obj)               │
     ▼                                 │
  取得 Monitor                         │
     │                                 │
     │ obj.wait()                      │
     ▼                                 │
  釋放 Monitor ──────────────────────► │ synchronized(obj)
  進入 Wait Set                        ▼
     │                              取得 Monitor
     │                                 │
     │                                 │ obj.notify()
     │ ◄───────────────────────────────┤
  被喚醒，移到 Entry List              │
     │                                 │ 離開 synchronized
     │ ◄───────────────────────────────┤ 釋放 Monitor
  重新取得 Monitor                     │
     │                                 │
     ▼                                 │
  從 wait() 返回                       │
```

<br>

**測試目標**：

```java
public class TestWaitNotify {
    static Object lock = new Object();
    static boolean ready = false;
    
    public static void main(String[] args) {
        Thread consumer = new Thread(() -> {
            synchronized (lock) {
                while (!ready) {
                    lock.wait();
                }
                System.out.println(2);  // 被喚醒後輸出
            }
        });
        
        Thread producer = new Thread(() -> {
            synchronized (lock) {
                ready = true;
                System.out.println(1);  // 先輸出
                lock.notify();
            }
        });
        
        consumer.start();
        Thread.sleep(100);  // 確保 consumer 先執行
        producer.start();
        
        // 預期輸出: 1, 2
    }
}
```
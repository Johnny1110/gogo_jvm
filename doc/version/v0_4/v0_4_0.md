# v0.4.0：Thread 基礎 (Thread Fundamentals)

<br>

---

<br>

**目標**：實現 java.lang.Thread 類與基本執行緒管理

* 深入理解 Java 執行緒模型與 JVM 執行緒的關係
* 理解執行緒狀態機（Thread State Machine）的設計
* 理解 Java Thread 與底層作業系統執行緒的映射關係
* 設計 GOGO JVM 的 Java Thread ↔ Go goroutine 映射策略
* 實現 `Thread.start()`, `Thread.join()`, `Thread.sleep()` 等核心方法
* 實現 Thread Local Storage (TLS) 與 `Thread.currentThread()`
* 為後續的 synchronized (v0.4.1) 和 wait/notify (v0.4.2) 打下基礎

<br>

---

<br>

## Part 1：Java 執行緒模型 — 理論基礎

<br>

### 1.1 什麼是執行緒？

#### 從作業系統角度

```
┌─────────────────────────────────────────────────────────────┐
│                           Process                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                 Shared Resources                    │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │    │
│  │  │   Heap      │  │   Code      │  │   Static    │  │    │
│  │  │  (Object)   │  │  (Method)   │  │   Data      │  │    │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐    │
│  │   Thread 1    │  │   Thread 2    │  │   Thread 3    │    │
│  │ ┌───────────┐ │  │ ┌───────────┐ │  │ ┌───────────┐ │    │
│  │ │   Stack   │ │  │ │   Stack   │ │  │ │   Stack   │ │    │
│  │ └───────────┘ │  │ └───────────┘ │  │ └───────────┘ │    │
│  │ ┌───────────┐ │  │ ┌───────────┐ │  │ ┌───────────┐ │    │
│  │ │    PC     │ │  │ │    PC     │ │  │ │    PC     │ │    │
│  │ └───────────┘ │  │ └───────────┘ │  │ └───────────┘ │    │
│  │ ┌───────────┐ │  │ ┌───────────┐ │  │ ┌───────────┐ │    │
│  │ │ Registers │ │  │ │ Registers │ │  │ │ Registers │ │    │
│  │ └───────────┘ │  │ └───────────┘ │  │ └───────────┘ │    │
│  └───────────────┘  └───────────────┘  └───────────────┘    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

<br>

#### 執行緒 (Thread) vs 進程 (Process)

| 特性         | 進程（Process）              | 執行緒（Thread）                 |
|--------------|------------------------------|----------------------------------|
| 資源隔離     | 獨立的記憶體空間             | 共享所屬進程的記憶體空間         |
| 創建開銷     | 大（需要複製/配置資源）      | 小（只需分配 Stack 等）          |
| 切換開銷     | 大（需要切換頁表）           | 小（只需切換 PC / SP）           |
| 通訊方式     | IPC（管道、共享記憶體等）    | 直接存取共享變數                 |
| 地址空間     | 獨立擁有完整的地址空間       | 共享進程地址空間                 |
| 私有資源     | 完整資源（Code / Data / Heap） | Stack、PC、Registers             |

<br>
<br>

### 1.2 Java 執行緒模型的特殊性

<br>

#### Java 執行緒是 "**輕量級**"，但不是 "**用戶態執行緒**"

早期 JVM（如 Green Thread）使用用戶態執行緒，現代 JVM 都使用 1:1 映射模型:

```
┌────────────────────────────────────────────────────────────────┐
│                        Java Application                        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│   ┌──────────────┐    ┌──────────────┐    ┌──────────────┐     │
│   │ Java Thread  │    │ Java Thread  │    │ Java Thread  │     │
│   │    (main)    │    │   (worker)   │    │   (daemon)   │     │
│   └──────┬───────┘    └──────┬───────┘    └──────┬───────┘     │
│          │                   │                   │             │
├──────────┼───────────────────┼───────────────────┼─────────────┤
│          │            JVM Native Layer           │             │
│          │                   │                   │             │
│   ┌──────▼───────┐    ┌──────▼───────┐    ┌──────▼───────┐     │
│   │  OS Thread   │    │  OS Thread   │    │  OS Thread   │     │
│   │  (pthread)   │    │  (pthread)   │    │  (pthread)   │     │
│   └──────────────┘    └──────────────┘    └──────────────┘     │
│                                                                │
│              1:1 Mapping（現代 JVM 的主流模型）                   │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

<br>

#### 為什麼 HotSpot JVM 選擇 1:1 映射？

| 模型 | 說明 | 優點 | 缺點 |
|----|----|----|----|
| N:1（Green Thread） | 多個使用者執行緒對應一個 OS 執行緒 | 創建快、切換快 | 無法利用多核 CPU、阻塞呼叫會卡住全部執行緒 |
| 1:1（Native Thread） | 一個使用者執行緒對應一個 OS 執行緒 | 真正並行、可充分利用多核 CPU | 建立與切換成本較高、OS 資源消耗大 |
| M:N（Hybrid） | 多個使用者執行緒對應多個 OS 執行緒 | 理論上效能與彈性最佳 | 實作複雜、除錯與維護困難 |

現代硬體的多核特性使得 1:1 模型成為最佳選擇。

<br>
<br>

### 1.3 JVM 內部的執行緒結構

<br>

#### HotSpot 的 JavaThread 結構（簡化版）

```
┌─────────────────────────────────────────────────────────────────┐
│                      JavaThread (C++)                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    Thread State                         │    │
│  │  _thread_state: ThreadState (NEW, RUNNABLE, BLOCKED...) │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                   Java Stack                            │    │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐                    │    │
│  │  │ Frame 0 │ │ Frame 1 │ │ Frame 2 │ ...                │    │
│  │  │ (main)  │ │(method1)│ │(method2)│                    │    │
│  │  └─────────┘ └─────────┘ └─────────┘                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                  Associated Objects                     │    │
│  │  _threadObj: oop  ──────────► java.lang.Thread Object   │    │
│  │  _pending_exception: oop ───► Current Exception         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    Synchronization                      │    │
│  │  _current_pending_monitor: ObjectMonitor*               │    │
│  │  _current_waiting_monitor: ObjectMonitor*               │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                     OS Thread                           │    │
│  │  _osthread: OSThread*  ──────► Native OS Thread Handle  │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

<br>

#### 三層關係

```
  Java Layer                  JVM Layer                   OS Layer
┌──────────────┐           ┌──────────────┐           ┌──────────────┐
│java.lang.    │           │  JavaThread  │           │  pthread_t   │
│  Thread      │ ◄───────► │   (C++)      │ ◄───────► │  (OS)        │
│  (Object)    │ threadObj │              │ osthread  │              │
└──────────────┘           └──────────────┘           └──────────────┘

    Java 程式                 JVM 內部實現                 作業系統核心
    可見的物件                 管理執行狀態                 實際的執行單元
```


<br>
<br>

---

<br>

## Part 2：執行緒狀態機 — Thread Lifecycle

<br>

### 2.1 Java 定義的六種執行緒狀態

<br>

#### `java.lang.Thread.State` 枚舉

```java
public enum State {
    NEW,           // 建立但尚未啟動
    RUNNABLE,      // 正在執行或等待 CPU 時間片
    BLOCKED,       // 等待取得 Monitor（synchronized）
    WAITING,       // 無限期等待（wait(), join()）
    TIMED_WAITING, // 有限期等待（sleep(n), wait(n)）
    TERMINATED     // 執行結束
}
```

<br>

```
                                 ┌─────────────────────────────────────────────────┐
                                 │                                                 │
                                 │                   "RUNNABLE"                    │
                                 │    ┌───────────────────────────────────────┐    │
                                 │    │                                       │    │
        new Thread()             │    │    ┌────────────┐      ┌─────────┐    │    │
             │                   │    │    │ Ready      │◄────►│ Running │    │    │
             ▼                   │    │    │(waitingCPU)│      │(ing...) │    │    │
        ┌─────────┐   start()    │    │    └────────────┘      └────┬────┘    │    │
        │  "NEW"  │─────────────►│    │                          │            │    │
        └─────────┘              │    └──────────────────────────┼────────────┘    │
                                 │                               │                 │
                                 └───────────────────────────────┼─────────────────┘
                                                                 │
                      ┌──────────────────────────────────────────┼──────────────────────────────┐
                      │                                          │                              │
                      │                                          │                              │
         synchronized │                                  wait()  │                  sleep(n)    │
         failed       │                                  join()  │                  wait(n)     │
                      │                                  park()  │                  join(n)     │
                      ▼                                          ▼                              ▼
                ┌───────────────┐                           ┌────────────┐               ┌───────────────┐
                │  "BLOCKED"    │                           │  "WAITING" │               │"TIMED_WAITING"│
                │               │                           │            │               │               │
                │waiting Monitor│                           │ waiting indefinitely       │ waiting for a limited time
                └─────┬─────────┘                           └─────┬──────┘               └──────┬────────┘
                      │                                           │                             │
                      │ Get Monitor                               │ notify()                    │ timeout/be woken up
                      │                                           │ notifyAll()                 │ 
                      │                                           │ unpark()                    │
                      │                                           │                             │
                      └───────────────────────────────────────────┴─────────────────────────────┘
                                                                  │
                                                                  │ (back to "RUNNABLE")
                                                                  │
                                                                  │
                                                           run() exit / throw exception
                                                                  │
                                                                  ▼
                                                           ┌───────────────┐
                                                           │ "TERMINATED"  │
                                                           │      end      │
                                                           └───────────────┘
```

<br>

### 2.3 各狀態的進入與離開條件


| 狀態 | 進入條件 | 離開條件 |
|------|----------|----------|
| **NEW** | `new Thread()` | `start()` 被呼叫 |
| **RUNNABLE** | `start()` / 從其他狀態恢復 | 進入等待狀態 / 執行結束 |
| **BLOCKED** | 嘗試進入 `synchronized` 區塊但 Monitor 被佔用 | 取得 Monitor |
| **WAITING** | `Object.wait()` / `Thread.join()` / `LockSupport.park()` | `notify()` / `notifyAll()` / `unpark()` |
| **TIMED_WAITING** | `Thread.sleep(n)` / `Object.wait(n)` / `Thread.join(n)` | 超時 / 被喚醒 |
| **TERMINATED** | `run()` 正常結束 / 拋出未捕獲異常 | 永遠不會離開 |

<br>

### 2.4 重要觀念：RUNNABLE 包含 "Ready" 和 "Running"


#### Java 的 `RUNNABLE` 狀態對應作業系統的兩種狀態：

```
┌──────────────────────────────────────────────────────────┐
│                    Java: RUNNABLE                        │
│                                                          │
│   ┌────────────────┐            ┌────────────────┐       │
│   │  OS: Ready     │ ◄────────► │  OS: Running   │       │
│   │  (WaitingCPU)  │  dispatch  │  (Occupy CPU)  │       │
│   └────────────────┘            └────────────────┘       │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

**JVM 無法區分這兩種狀態，因為這是 OS 調度器的職責**，這是因為 JVM 執行於作業系統之上，無法直接知道某個執行緒是否正在 CPU 上執行。

<br>
<br>

---

<br>

## Part 3：·java.lang.Thread` 類的核心設計

<br>

### 3.1 Thread 類的關鍵欄位

```java
public class Thread implements Runnable {

    // ========== 執行緒身份 ==========
    private volatile String name;          // 執行緒名稱
    private int priority;                  // 優先級 (1-10, 預設 5)
    private long tid;                      // 執行緒 ID（唯一識別）
    
    // ========== 執行相關 ==========
    private Runnable target;               // run() 要執行的任務
    private ThreadGroup group;             // 所屬的執行緒群組
    
    // ========== 狀態控制 ==========
    private volatile int threadStatus;     // 內部狀態（對應 Thread.State）
    private boolean daemon = false;        // 是否為守護執行緒
    
    // ========== 執行緒私有資料 ==========
    ThreadLocal.ThreadLocalMap threadLocals;        // ThreadLocal 資料
    ThreadLocal.ThreadLocalMap inheritableThreadLocals;  // 可繼承的 ThreadLocal
    
    // ========== 同步相關（v0.4.1+ 會用到）==========
    private volatile Interruptible blocker;  // 中斷處理器
    private final Object blockerLock = new Object();
    
    // ========== 常數 ==========
    public static final int MIN_PRIORITY = 1;
    public static final int NORM_PRIORITY = 5;
    public static final int MAX_PRIORITY = 10;
}
```

<br>
<br>

### 3.2 Thread 的核心方法

<br>

| 方法 | 類型 | 功能 | v0.4.0 實現 |
|------|------|------|-----------|
| `start()` | instance | 啟動執行緒（只能呼叫一次） | yes       |
| `run()` | instance | 執行緒的執行體 |        yes    |
| `join()` | instance | 等待此執行緒結束 |      yes      |
| `join(long)` | instance | 帶超時的等待 |       yes     |
| `sleep(long)` | static | 暫停當前執行緒 |        yes    |
| `yield()` | static | 讓出 CPU 時間片 |          yes  |
| `currentThread()` | static | 取得當前執行緒 |       yes     |
| `isAlive()` | instance | 檢查執行緒是否存活 |        yes    |
| `getState()` | instance | 取得執行緒狀態 |          yes  |
| `interrupt()` | instance | 中斷執行緒 | v0.4.3    |
| `isInterrupted()` | instance | 檢查中斷狀態 | v0.4.3    |

<br>
<br>

### 3.3 執行緒啟動的完整流程

<br>

#### Java 層面

```java
Thread t = new Thread(() -> {
    System.out.println("Hello from new thread!");
});
t.start();  // 不是直接呼叫 run()!
```

<br>

#### JVM 內部流程

```
  t.start() 呼叫
       │
       ▼
  ─────────────────────────────────────────────────────────────
   1. 檢查狀態                                                  
      if (threadStatus != 0)                                   
          throw new IllegalThreadStateException()              
      // 已經 start 過的執行緒不能再 start                        
  ─────────────────────────────────────────────────────────────
       │
       ▼
  ─────────────────────────────────────────────────────────────
   2. 加入執行緒群組                                             
      group.add(this)                                          
  ─────────────────────────────────────────────────────────────
       │
       ▼
  ─────────────────────────────────────────────────────────────
   3. 呼叫 native start0()                                      
      - 在 JVM 層創建 JavaThread                                 
      - 在 OS 層創建 native thread (pthread_create)              
      - 設定執行緒狀態為 RUNNABLE                                 
  ─────────────────────────────────────────────────────────────
       │
       ▼
  ─────────────────────────────────────────────────────────────
   4. 新執行緒開始執行                                            
      - OS 調度器分配 CPU 時間                                    
      - JVM 呼叫 Thread.run()                                   
      - run() 內部呼叫 target.run()（如果 target != null）        
  ─────────────────────────────────────────────────────────────
       │
       ▼
  ─────────────────────────────────────────────────────────────
   5. run() 結束                                                
      - 設定狀態為 TERMINATED                                    
      - 喚醒所有 join() 等待的執行緒                              
      - 從執行緒群組移除                                         
  ─────────────────────────────────────────────────────────────
```

<br>
<br>

---

<br>

## Part 4：GOGO JVM 的設計策略 — Java Thread <-> Go goroutine

<br>

### 4.1 為什麼選擇 goroutine？

#### Go 的 goroutine 特性

```
┌─────────────────────────────────────────────────────────────────┐
│                      Go Runtime                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐       │
│   │goroutine 1│ │goroutine 2│ │goroutine 3│ │goroutine N│       │
│   └─────┬─────┘ └─────┬─────┘ └─────┬─────┘ └─────┬─────┘       │
│         │             │             │             │             │
│         └─────────────┴─────────────┴─────────────┘             │
│                             │                                   │
│                       M:N dispatch                              │
│                             │                                   │
│           ┌─────────────────┼─────────────────┐                 │
│           │                 │                 │                 │
│     ┌─────▼─────┐     ┌─────▼─────┐     ┌─────▼─────┐           │
│     │ OS Thread │     │ OS Thread │     │ OS Thread │           │
│     │   (M=1)   │     │   (M=2)   │     │   (M=N)   │           │
│     └───────────┘     └───────────┘     └───────────┘           │
└─────────────────────────────────────────────────────────────────┘
```

* goroutine 數量可以遠大於 OS Thread 數量
* Go Runtime 負責調度，使用者無需關心

<br>

#### goroutine vs pthread

| 特性 | pthread (OS Thread) | goroutine |
|------|---------------------|-----------|
| Stack 大小 | ~1-8 MB (固定) | ~2 KB (動態增長) |
| 創建開銷 | 高（系統呼叫） | 低（用戶態分配） |
| 切換開銷 | 高（上下文切換） | 低（Go Runtime 內部） |
| 數量限制 | 數千個 | 數百萬個 |
| 調度 | OS 核心 | Go Runtime (M:N) |

<br>

#### GOGO JVM 選擇 goroutine 的理由

1. **簡化實現**：Go 已經處理好複雜的執行緒調度
2. **輕量級**：創建 Java Thread 只需創建 goroutine，開銷很小
3. **自然的並發**：Go 的 channel 可以輕鬆實現執行緒間通訊
4. **跨平台**：Go Runtime 處理了所有平台差異


<br>
<br>

### 4.2 映射架構設計

<br>

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        GOGO JVM Architecture                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Java Layer                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                    java.lang.Thread (Object)                    │    │
│  │  ┌─────────────────────────────────────────────────────────┐    │    │
│  │  │  name: String                                           │    │    │
│  │  │  priority: int                                          │    │    │
│  │  │  daemon: boolean                                        │    │    │
│  │  │  target: Runnable                                       │    │    │
│  │  │  threadStatus: int  ←── 狀態由 JVM Thread 同步            │    │    │
│  │  └─────────────────────────────────────────────────────────┘    │    │
│  └───────────────────────────────┬─────────────────────────────────┘    │
│                                  │                                      │
│                                  │ 雙向引用（Mirror）                     │
│                                  │                                      │
│  JVM Layer                       ▼                                      │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                    runtime.JVMThread (Go struct)                │    │
│  │  ┌─────────────────────────────────────────────────────────┐    │    │
│  │  │  javaThread: *heap.Object  ──► java.lang.Thread Object  │    │    │
│  │  │  state: ThreadState                                     │    │    │
│  │  │  jvmStack: *JVMStack       ──► Java Method Stack        │    │    │
│  │  │  pc: int                                                │    │    │
│  │  │  daemon: bool                                           │    │    │
│  │  │                                                         │    │    │
│  │  │  // Go Runtime 相關                                      │    │    │
│  │  │  done: chan struct{}       ──► 用於 join() 等待          │    │    │
│  │  │  interruptCh: chan struct{}──► 用於中斷通知               │    │    │
│  │  └─────────────────────────────────────────────────────────┘    │    │
│  └───────────────────────────────┬─────────────────────────────────┘    │
│                                  │                                      │
│                                  │ start() create                       │
│                                  │                                      │
│  Go Runtime Layer                ▼                                      │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                         goroutine                               │    │
│  │  ┌─────────────────────────────────────────────────────────┐    │    │
│  │  │  執行 JVMThread.run() 方法                               │    │    │
│  │  │  - 呼叫 Java Thread.run() 的 bytecode                    │    │    │
│  │  │  - 處理異常                                              │    │    │
│  │  │  - 結束時設定狀態並關閉 done channel                       │    │    │
│  │  └─────────────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

<br>
<br>

### 4.3 Thread Local Storage (TLS) 設計

<br>

#### 為什麼需要 TLS？

`Thread.currentThread()` 是一個 static 方法，但必須返回 "**當前**" 執行緒的 `Thread` 物件。這需要某種機制讓每個執行緒能找到 "**自己**" 的資料。

<br>

#### GOGO JVM 的 TLS 策略

```go
// 方案：使用 Go 的 goroutine-local storage 模擬

// 全域的執行緒映射表
var (
    threadMapMutex sync.RWMutex
    threadMap      = make(map[int64]*JVMThread)  // goroutineID -> JVMThread
)

// 取得當前 JVMThread
func CurrentThread() *JVMThread {
    gid := getGoroutineID()  // 取得當前 goroutine 的 ID
    
    threadMapMutex.RLock()
    defer threadMapMutex.RUnlock()
    
    return threadMap[gid]
}

// 註冊 JVMThread（在 goroutine 開始時呼叫）
func registerThread(t *JVMThread) {
    gid := getGoroutineID()
    
    threadMapMutex.Lock()
    defer threadMapMutex.Unlock()
    
    threadMap[gid] = t
}

// 取消註冊（在 goroutine 結束時呼叫）
func unregisterThread() {
    gid := getGoroutineID()
    
    threadMapMutex.Lock()
    defer threadMapMutex.Unlock()
    
    delete(threadMap, gid)
}
```

<br>

#### 取得 goroutine ID 的方法（運行時 hack）

```go
import "runtime"

func getGoroutineID() int64 {
    var buf [64]byte
    n := runtime.Stack(buf[:], false)
    // Stack 輸出格式: "goroutine 123 [running]:\n..."
    // 解析出 goroutine ID
    idField := strings.Fields(strings.TrimPrefix(string(buf[:n]), "goroutine "))[0]
    id, _ := strconv.ParseInt(idField, 10, 64)
    return id
}
```


<br>
<br>

---

<br>

## Part 5：核心方法的實現設計

<br>

### 5.1 `Thread.start()`

<br>

#### 設計要點

```
Thread.start() 執行流程:

  Java: t.start()
        │
        ▼
  Native: Thread_start0()
        │
        ├─── 1. 檢查狀態（必須是 NEW）
        │
        ├─── 2. 創建 JVMThread 結構
        │
        ├─── 3. 建立雙向引用
        │         jvmThread.javaThread = threadObject
        │         threadObject.setInternalThread(jvmThread)
        │
        ├─── 4. 設定狀態為 RUNNABLE
        │
        ├─── 5. 啟動 goroutine
        │         go jvmThread.run()
        │
        └─── 6. 返回（不等待 goroutine）
```

<br>
<br>

### 5.2 `Thread.run()` 的執行

<br>

#### `JVMThread.run()` 的設計

```go
func (t *JVMThread) run() {
    // 1. 取得 Thread.run() 方法
    threadClass := t.javaThread.Class().(*method_area.Class)
    runMethod := threadClass.GetMethod("run", "()V")
    
    // 2. 創建新的 Frame
    frame := t.NewFrameWithMethod(runMethod)
    
    // 3. 設定 this 引用
    frame.LocalVars().SetRef(0, t.javaThread)
    
    // 4. 壓入 JVM Stack
    t.PushFrame(frame)
    
    // 5. 開始解釋執行
    interpret(t)
}
```

<br>

#### 注意：`Thread.run()` 的實際行為

```java
// Thread.run() 的預設實現
public void run() {
    if (target != null) {
        target.run();  // 如果有 Runnable，呼叫它的 run()
    }
}
```

所以當使用 `new Thread(runnable)` 時：

1. `Thread.run()` 被呼叫
2. `run()` 內部呼叫 `target.run()`
3. 實際執行 Runnable 的邏輯

<br>
<br>

### 5.3 `Thread.join()`

<br>

#### 設計要點

Thread.join() 的語義:
* 當前執行緒等待目標執行緒結束
* 可以設定超時時間
* 可以被中斷（拋出 `InterruptedException`）

> Thread.join() 的標準實現其實內部使用了 synchronized 和 wait() 這涉及到物件頭鎖狀態，需要等到 v0.4.2 重構ˋ join() 方法以符合 JVM 標準

```
v0.4.0  Thread 基礎
        └── join() 使用 Go channel 簡化實現
                    │
                    │ 重構
                    ▼
v0.4.1  synchronized
        └── 實現 Monitor / monitorenter / monitorexit
                    │
                    │ 基於 Monitor
                    ▼
v0.4.2  wait / notify
        └── 重構 join() 為標準實現（synchronized + wait）
```

<br>

**使用 Go channel 實現**

<br>
<br>

### 5.4 `Thread.sleep()`

<br>

#### 設計要點

`Thread.sleep(long millis)` 的語義:
* 暫停當前執行緒指定的毫秒數
* 不釋放任何鎖（與 `wait()` 不同）
* 可以被中斷（拋出 `InterruptedException`）
* 睡眠期間狀態為 `TIMED_WAITING`


<br>
<br>

### 5.5 `Thread.yield()`

<br>

#### 設計要點

`Thread.yield()` 的語義:
* 提示調度器當前執行緒願意讓出 CPU
* 只是 "提示"，調度器可以忽略
* 執行緒仍然是 `RUNNABLE` 狀態


<br>
<br>

### 5.7 `Thread.isAlive()`

`Thread.isAlive()` 的語義:
* 如果執行緒已經 `start()` 且尚未 terminate，返回 true
* `NEW` 狀態返回 false
* `TERMINATED` 狀態返回 false


<br>
<br>

---

<br>

## Part 6：Daemon Thread（守護執行緒）

<br>

### 6.1 什麼是 Daemon Thread？

| 分類            | 說明                                                                 |
|-----------------|----------------------------------------------------------------------|
| User Thread     | - 包含 `main` 執行緒<br>- 使用者自行建立的一般執行緒<br>- JVM 會等待所有 User Thread 結束後才會退出 |
| Daemon Thread   | - 背景服務型執行緒<br>- 常見如：GC、Finalizer、Signal Dispatcher<br>- 當所有 User Thread 結束時，Daemon Thread 會自動終止 |

<br>
<br>

### 6.2 JVM 退出條件

<br>

JVM 退出判斷:
```
  while (true) {
      count = 計算存活的 User Thread 執行緒數量
      
      if (count == 0) {
          // 所有 User Thread 都結束了
          // Daemon Thread 會被強制終止
          System.exit(0)
      }
      
      等待某個執行緒結束的通知
  }
```

<br>
<br>

---

<br>

## Part 7：與現有架構的整合

<br>

### 7.1 需要修改的現有模組

<br>

**1. runtime/thread.go**

目前的 `Thread` 結構需要大幅重構：

```go
// 原本（v0.3.x）
type Thread struct {
    pc        int
    jvmStack  *JVMStack
}

// 新版（v0.4.0）
type JVMThread struct {
    // 基本資訊
    id         int64
    name       string
    daemon     bool
    
    // 狀態
    state      ThreadState
    
    // JVM Stack
    pc         int
    jvmStack   *JVMStack
    
    // Java 物件引用
    javaThread *heap.Object
    
    // 同步相關
    done       chan struct{}
    
    // 用於 interrupt (v0.4.3)
    interrupted bool
    interruptCh chan struct{}
}
```

<br>

**2. interpreter/interpreter.go**

解釋器需要支援多執行緒：

```go
// 原本：全域函數
func Interpret(method *method_area.Method, debug bool) {
    thread := runtime.NewThread()
    // ...
}

// 新版：支援指定執行緒
func Interpret(thread *JVMThread, method *method_area.Method, debug bool) {
    // ...
}

// 或者：在 JVMThread 上呼叫
func (t *JVMThread) Interpret(method *method_area.Method, debug bool) {
    // ...
}
```

<br>

**3. native/java/lang/thread.go**

完善現有的空實現：

```go
func init() {
    runtime.Register("java/lang/Thread", "start0", "()V", threadStart0)
    runtime.Register("java/lang/Thread", "sleep", "(J)V", threadSleep)
    runtime.Register("java/lang/Thread", "yield", "()V", threadYield)
    runtime.Register("java/lang/Thread", "currentThread", "()Ljava/lang/Thread;", threadCurrentThread)
    runtime.Register("java/lang/Thread", "isAlive", "()Z", threadIsAlive)
    runtime.Register("java/lang/Thread", "setPriority0", "(I)V", threadSetPriority0)
}
```

<br>
<br>

### 7.2 新增模組

<br>

**1. runtime/thread_manager.go**

```go
// 全域執行緒管理器
type ThreadManager struct {
    mutex          sync.RWMutex
    threads        map[int64]*JVMThread  // id -> thread
    goroutineMap   map[int64]*JVMThread  // goroutineID -> thread
    nextThreadId   int64
    nonDaemonCount int32
}

var globalThreadManager = &ThreadManager{
    threads:      make(map[int64]*JVMThread),
    goroutineMap: make(map[int64]*JVMThread),
}

func (tm *ThreadManager) Register(t *JVMThread) { ... }
func (tm *ThreadManager) Unregister(t *JVMThread) { ... }
func (tm *ThreadManager) CurrentThread() *JVMThread { ... }
func (tm *ThreadManager) AllThreads() []*JVMThread { ... }
```

<br>

**2. runtime/thread_state.go**

```go
type ThreadState int

const (
    THREAD_STATE_NEW ThreadState = iota
    THREAD_STATE_RUNNABLE
    THREAD_STATE_BLOCKED
    THREAD_STATE_WAITING
    THREAD_STATE_TIMED_WAITING
    THREAD_STATE_TERMINATED
)

// 狀態轉換驗證
func (s ThreadState) CanTransitionTo(target ThreadState) bool {
    // 定義合法的狀態轉換
}
```

<br>
<br>

---

<br>


## Part 9：實現清單

<br>

### 新增檔案

| 檔案路徑 | 說明 |
|----------|------|
| `runtime/jvm_thread.go` | 新的 JVMThread 結構定義 |
| `runtime/thread_manager.go` | 全域執行緒管理器 |
| `runtime/thread_state.go` | 執行緒狀態定義與轉換 |
| `runtime/tls.go` | Thread Local Storage 實現 |

<br>

### 修改檔案

| 檔案路徑 | 修改內容 |
|----------|----------|
| `runtime/thread.go` | 重構為支援多執行緒 |
| `runtime/frame.go` | 關聯到 JVMThread |
| `interpreter/interpreter.go` | 支援多執行緒解釋執行 |
| `native/java/lang/thread.go` | 實現 Thread 的 native 方法 |
| `cmd/gogo_jvm/main.go` | 初始化主執行緒 |

<br>

### Native 方法清單

| 方法簽名 | 功能 |
|----------|------|
| `Thread.start0()V` | 啟動執行緒（內部方法） |
| `Thread.sleep(J)V` | 執行緒睡眠 |
| `Thread.yield()V` | 讓出 CPU |
| `Thread.currentThread()Ljava/lang/Thread;` | 取得當前執行緒 |
| `Thread.isAlive()Z` | 檢查執行緒是否存活 |
| `Thread.setPriority0(I)V` | 設定優先級（可能只是記錄，不實際影響調度） |

<br>

---

<br>

## 總結


<br>

### 為什麼 Java Thread 使用 1:1 映射到 OS Thread？

**歷史演進**：早期 JVM 使用 Green Thread（M:N），但無法利用多核 CPU。現代 JVM 選擇 1:1 映射以獲得真正的並行能力。

**權衡**：雖然 OS Thread 的創建和切換開銷較大，但現代 OS 已經大幅優化，且 1:1 模型的實現和調試都更簡單。

<br>

### 為什麼 GOGO JVM 使用 goroutine？

**簡化實現**：Go 的 goroutine 提供了輕量級的並發原語，讓我們可以專注於 JVM 語義的實現，而不是處理複雜的執行緒調度。

**學習目的**：GOGO JVM 是教學級實現，使用 goroutine 可以快速驗證 Java 多執行緒語義的正確性。

<br>

### Thread.start() vs Thread.run() 的本質差異

**start()**：創建新的執行上下文（新的 Stack、PC），在新的執行緒中執行 run()。

**run()**：只是普通方法呼叫，在當前執行緒的 Stack 上執行。

<br>

### Thread Local Storage 的重要性

**問題**：`Thread.currentThread()` 是 static 方法，如何知道 "當前" 是哪個執行緒？

**解決**：每個執行緒（goroutine）有自己的 ID，通過全域映射表找到對應的 JVMThread。

<br>

---

<br>

## 參考資料

* [Java Language Specification - Threads and Locks](https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html)
* [JVM Specification - Threads](https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-2.html#jvms-2.5.2)
* [OpenJDK HotSpot Thread Implementation](https://github.com/openjdk/jdk/blob/master/src/hotspot/share/runtime/thread.hpp)
* [Go Runtime - goroutine scheduling](https://go.dev/src/runtime/proc.go)
* [The Go Memory Model](https://go.dev/ref/mem)
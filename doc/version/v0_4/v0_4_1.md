# v0.4.1：synchronized 同步

<br>

---

<br>

**目標**：實現 `synchronized` 關鍵字與 Monitor 機制

**需要實現的指令**：

| 指令 | Opcode | 功能 |
|------|--------|------|
| `monitorenter` | `0xC2` | 進入同步區塊（取得鎖） |
| `monitorexit` | `0xC3` | 離開同步區塊（釋放鎖） |

<br>

**Monitor 結構**：

```
每個物件都有一個關聯的 Monitor：

  ┌─────────────────────────────────────┐
  │             Monitor                 │
  ├─────────────────────────────────────┤
  │ owner: Thread         (鎖的擁有者)  │
  │ entryCount: int       (重入次數)    │
  │ waitSet: Set<Thread>  (等待集合)    │
  │ entryList: List<Thread>(阻塞佇列)   │
  └─────────────────────────────────────┘

  synchronized(obj) {
      // monitorenter: 嘗試取得 obj 的 Monitor
      //               成功 → owner = currentThread
      //               失敗 → 加入 entryList 等待
      
      // ... 臨界區 ...
      
      // monitorexit: 釋放 Monitor
      //              entryCount--
      //              如果 entryCount == 0，喚醒 entryList 中的執行緒
  }
```

<br>

**測試目標**：

```java
public class TestSynchronized {
    static int counter = 0;
    static Object lock = new Object();
    
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                synchronized (lock) {
                    counter++;
                }
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                synchronized (lock) {
                    counter++;
                }
            }
        });
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        
        System.out.println(counter);  // 應該輸出 2000
    }
}
```

<br>
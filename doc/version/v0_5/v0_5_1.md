# v0.5.1：Mark-Sweep GC

<br>

---

<br>

**目標**：實現最基本的標記-清除垃圾回收器

**三色標記法**：

```
三色抽象：
┌────────────────────────────────────────────────────────┐
│ 白色：尚未訪問的物件（GC 結束後，白色物件將被回收）      │
│ 灰色：已訪問但其引用尚未掃描的物件                      │
│ 黑色：已訪問且其所有引用都已掃描的物件（確定存活）       │
└────────────────────────────────────────────────────────┘

標記過程：
1. 初始時，所有物件都是白色
2. 將 GC Roots 直接引用的物件標記為灰色
3. 從灰色物件中取出一個：
   a. 將其所有引用的白色物件標記為灰色
   b. 將該物件標記為黑色
4. 重複步驟 3，直到沒有灰色物件
5. 此時，白色物件即為垃圾
```

<br>

**實現代碼框架**：

```go
// runtime/gc/mark_sweep.go

type MarkSweepGC struct {
    heap      *Heap
    white     map[*Object]bool  // 未標記
    gray      []*Object          // 待處理佇列
    black     map[*Object]bool  // 已標記
}

func (gc *MarkSweepGC) Mark() {
    // 1. 初始化：所有物件都是白色
    gc.white = gc.heap.AllObjects()
    gc.gray = []*Object{}
    gc.black = make(map[*Object]bool)
    
    // 2. 將 GC Roots 加入灰色佇列
    for _, root := range EnumerateGCRoots() {
        gc.markGray(root)
    }
    
    // 3. 處理灰色物件
    for len(gc.gray) > 0 {
        obj := gc.gray[len(gc.gray)-1]
        gc.gray = gc.gray[:len(gc.gray)-1]
        
        gc.scanObject(obj)
        gc.black[obj] = true
    }
}

func (gc *MarkSweepGC) Sweep() {
    // 回收所有白色物件
    for obj := range gc.white {
        gc.heap.Free(obj)
    }
}
```

<br>

**記憶體碎片問題**：

```
Mark-Sweep 後的記憶體狀態：

  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
  │ A │   │ B │   │   │ C │   │ D │   │   │
  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
        ↑       ↑   ↑       ↑       ↑   ↑
        空閒     空閒碎片     空閒     空閒碎片

問題：雖然總空閒空間足夠，但無法分配大物件
解決：Mark-Compact（壓縮）
```

<br>

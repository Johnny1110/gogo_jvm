# v0.5.5：併發 GC 基礎

<br>

---

<br>

**目標**：實現併發標記，減少 Stop-The-World 時間

**併發標記的挑戰**：

```
問題：標記過程中，應用執行緒修改了引用關係

  GC Thread              Application Thread
      │                         │
      │ 標記 A 為黑色           │
      │ (A 的所有引用已掃描)    │
      │                         │
      │                         │ A.field = C  (新引用)
      │                         │ B.field = null (刪除原引用)
      │                         │
      │ 掃描 B                   │
      │ (沒發現 C)               │
      │                         │
      ▼                         ▼
    C 被誤認為垃圾！錯誤回收！
```

<br>

**解決方案：寫屏障（Write Barrier）**：

```
兩種策略：

1. SATB（Snapshot-At-The-Beginning）- G1 使用
   ┌─────────────────────────────────────────────────────┐
   │ 在 GC 開始時，記錄引用關係的快照                     │
   │ 寫屏障：記錄被刪除的引用（B.field = null 時記錄 C）  │
   │ 確保快照中可達的物件不會被誤回收                    │
   └─────────────────────────────────────────────────────┘

2. Incremental Update - CMS 使用
   ┌─────────────────────────────────────────────────────┐
   │ 寫屏障：記錄新增的引用（A.field = C 時標記 A 為灰色）│
   │ 需要重新掃描被修改的黑色物件                        │
   └─────────────────────────────────────────────────────┘
```

<br>

**實現框架**：

```go
// runtime/gc/write_barrier.go

// SATB 寫屏障
func SATBWriteBarrier(slot *Object, oldValue *Object) {
    if gcPhase == MARKING && oldValue != nil {
        // 記錄被覆蓋的引用
        satbQueue.Push(oldValue)
    }
}

// 欄位寫入時調用
func (o *Object) SetField(index int, value *Object) {
    oldValue := o.fields[index]
    SATBWriteBarrier(&o.fields[index], oldValue)
    o.fields[index] = value
}
```

<br>
# v0.5.4：分代 GC

<br>

---

<br>

**目標**：實現分代垃圾回收，結合 Copying GC 和 Mark-Compact

**分代假說**：

```
分代假說（Generational Hypothesis）：
┌──────────────────────────────────────────────────────────┐
│ 大多數物件在創建後很快就會死亡（朝生夕滅）                 │
│ 熬過多次 GC 的物件，往往能繼續存活很長時間                 │
└──────────────────────────────────────────────────────────┘

基於此假說的分代策略：
- Young Gen：使用 Copying GC（大多數物件會死）
- Old Gen：使用 Mark-Compact（物件存活率高）
```

<br>

**GC 觸發與晉升**：

```
Minor GC（Young Gen GC）：
1. 當 Eden 區滿時觸發
2. 複製 Eden + From Survivor 中的存活物件到 To Survivor
3. 存活超過閾值（如 15 次）的物件晉升到 Old Gen
4. 交換 From 和 To

Major GC / Full GC（Old Gen GC）：
1. 當 Old Gen 空間不足時觸發
2. 對 Old Gen 進行 Mark-Compact
3. 通常會順帶做一次 Minor GC

物件晉升：
  ┌─────────────────────────────────────────────────────┐
  │                                                     │
  │  Eden ──┬──► Survivor ──┬──► Survivor ──► Old Gen  │
  │         │               │                          │
  │         │   age++       │   age >= 15              │
  │         │               │                          │
  │         └───► 死亡      └───► 死亡                  │
  │                                                     │
  └─────────────────────────────────────────────────────┘
```

<br>

**跨代引用處理（Remember Set）**：

```
問題：Minor GC 時，如何知道 Old Gen 引用了哪些 Young Gen 物件？

  Old Gen              Young Gen
  ┌───────────┐        ┌───────────┐
  │     A     │───────►│     X     │  ← 這個引用怎麼辦？
  └───────────┘        └───────────┘

解決：Remember Set（或 Card Table）

  ┌─────────────────────────────────────────────────────┐
  │ Card Table：將 Old Gen 劃分為 512 byte 的 Card      │
  │ 每個 Card 有一個標記位                              │
  │ 當 Old Gen 物件引用 Young Gen 時，標記對應 Card     │
  │ Minor GC 時，只掃描被標記的 Card                    │
  └─────────────────────────────────────────────────────┘
```

<br>

# XorShift32 算法

<br>

---

<br>

Hot Spot JVM 預設使用 Marsaglia XorShift 演算法生成 Object 的 identity hash code

特性: 
* 速度快: 只需位元運算，無乘除法
* 分佈均勻: 統計特性良好
* 確定性: 相同種子產生相同序列

<br>
<br>

## 演算法本質

XorShift 是一種偽隨機數生成器 (PRNG)，由 George Marsaglia 在 2003 年提出。它的核心思想是：

> 透過位元的「移位」和「互斥或」操作，讓位元充分混合，產生看似隨機的數列。

<br>
<br>

## 逐行解析 XorShift32

```go
func generateHashCode() int32 {
    hashMutex.Lock()
    defer hashMutex.Unlock()

    // XorShift32 演算法
    x := hashState      // 步驟 1: 讀取當前狀態
    x ^= x << 13        // 步驟 2: 左移 13 位，XOR
    x ^= x >> 17        // 步驟 3: 右移 17 位，XOR
    x ^= x << 5         // 步驟 4: 左移 5 位，XOR
    hashState = x       // 步驟 5: 保存新狀態

    result := int32(x & 0x7FFFFFFF)  // 步驟 6: 取 31 bits
    if result == 0 {
        result = 1      // 步驟 7: 確保不為 0
    }
    return result
}
```

<br>

### 步驟 1: 讀取當前狀態

```go
x := hashState
```

hashState 是一個 32-bit 的狀態變數，初始值來自系統時間：

```go
func init() {
    hashState = uint32(time.Now().UnixNano())
}
```

**為什麼用時間？**: 確保每次 JVM 啟動時，hashCode 序列都不同。

<br>

### 步驟 2~4: XorShift 核心操作

假設 `x = 0x12345678` (初始狀態)

二進位: `0001 0010 0011 0100 0101 0110 0111 1000`

<br>

#### 步驟 2: `x ^= x << 13`

```
x          = 0001 0010 0011 0100 0101 0110 0111 1000
x << 13    = 1010 0010 1100 1111 0000 0000 0000 0000
             ↑ 左移 13 位，右邊補 0
            
x XOR(互斥) = 1011 0000 1111 0000 0101 0110 0111 1000
             ↑ 結果：高位和低位的資訊混合了
```

**目的**：將低位的資訊「擴散」到高位

<br>

#### 步驟 3: `x ^= x >> 17`

```
x         = 1011 0000 1111 0000 0101 0110 0111 1000
x >> 17   = 0000 0000 0000 0000 0101 1000 0111 1000
            ↑ 右移 17 位，左邊補 0
            
x XOR     = 1011 0000 1111 0000 0000 1110 0000 0000
            ↑ 結果：高位的資訊「擴散」到低位
```

**目的**：將高位的資訊「擴散」到低位

<br>

#### 步驟 4: `x ^= x << 5`

```
x         = 1011 0000 1111 0000 0000 1110 0000 0000
x << 5    = 0001 1110 0000 0001 1100 0000 0000 0000

x XOR     = 1010 1110 1111 0001 1100 1110 0000 0000
            ↑ 結果：進一步混合
```

**目的**：再次混合，確保每個 bit 都受到其他 bits 的影響

<br>
<br>

#### 為什麼是 13, 17, 5 這三個數字？

Marsaglia 經過數學分析和實驗，找出能產生最大週期的參數組合。

| 參數組合        | 週期長度                  | 品質評價 | 備註說明                     |
|-----------------|---------------------------|----------|------------------------------|
| (13, 17, 5)     | 2³² − 1（約 43 億）        | 高       | 參數選擇良好，週期完整       |
| (1, 3, 10)      | 週期很短                  | 差       | 參數不佳，隨便選擇           |
| 任意隨機參數    | 可能非常短                | 不穩定   | 容易產生劣質隨機性           |

<br>

**週期 = 2³² - 1 意味著**: 在重複之前，可以產生約 43 億個不同的數字。

<br>
<br>

### 步驟 5: 保存新狀態

```go
hashState = x
```

下次呼叫時，會從這個新狀態繼續。這就是為什麼它叫 "hash 狀態機"。

* 第 1 次呼叫: hashState = A → 產生 B → hashState = B
* 第 2 次呼叫: hashState = B → 產生 C → hashState = C
* 第 3 次呼叫: hashState = C → 產生 D → hashState = D

<br>
<br>

### 步驟 6: 取 31 bits

```go
result := int32(x & 0x7FFFFFFF)
```

```
x           = 1010 1110 1111 0001 1100 1110 0000 0000
0x7FFFFFFF  = 0111 1111 1111 1111 1111 1111 1111 1111
              ↑ 最高位是 0

x AND       = 0010 1110 1111 0001 1100 1110 0000 0000
              ↑ 結果：最高位被清除，確保是正數
```

Java 的 hashCode() 返回 int，但習慣上期望是正數。清除最高位（符號位）確保結果永遠 ≥ 0。

<br>
<br>

### 步驟 7: 確保不為 0

在 Mark Word 中，hashCode = 0 代表「尚未計算」：

#### 為什麼 0 不行？

```go
func (o *Object) HashCode() int32 {
    hash := int32((mark & HashCodeMask) >> HashCodeShift)
    
    if hash != 0 {
        return hash  // 已經有值，直接返回
    }
    
    // hash == 0 表示還沒算過，需要生成新的
    newHash := generateHashCode()
    // ...
}
```

如果允許 hashCode = 0，就無法區分「尚未計算」和「計算結果剛好是 0」。

<br>

---

<br>

## XorShift 位元擴散過程

```
初始狀態 (假設只有 1 個 bit 是 1): 
 
x = 0000 0000 0000 0000 0000 0000 0000 0001
                                          ↑                 
                                         只有這個 bit 是 1
 
經過 x ^= x << 13: (XOR)

x = 0000 0000 0000 0010 0000 0000 0000 0001                   
                     ↑                    ↑                      
                   新的 1               原本的 1   
                   
                   
經過 x ^= x >> 17: (XOR)
x = 0000 0000 0000 0010 0000 0000 0000 0001
(這個例子變化不明顯，因為右移後超出範圍)


經過 x ^= x << 5: (XOR)

x = 0000 0000 0000 0110 0000 0000 0010 0001                   
                    ↑↑              ↑     ↑                    
                   更多 1 出現了           原本的 1   

```

一個 bit 的變化會 "__擴散__" 到整個數字，這就是 XorShift 的精髓。

<br>

---

<br>

## 為什麼 HotSpot 選擇 XorShift？

HashMap.put(key, value):

1. `hash = key.hashCode()` 每次 put 都會呼叫
2. `bucket = hash % capacity`
3. 放入對應的 `bucket`

如果 `hashCode()` 很慢:

* HashMap 效能下降
* 整個應用程式變慢

**XorShift 的優勢**:

* 只需要 3 次移位 + 3 次 XOR
* 沒有乘法、除法、取模
* CPU 可以在幾個 cycle 內完成



# Bytecode instructions 解釋器

<br>

---

<br>

## 解釋器的核心：Fetch-Decode-Execute 循環

```
┌─────────────────────────────────────────────────────────────────┐
│                    解釋器工作原理                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│    ┌──────────────────────────────────────────────────────┐    │
│    │                                                      │    │
│    │    ┌─────────┐    ┌─────────┐    ┌─────────┐        │    │
│    │    │  Fetch  │ →  │ Decode  │ →  │ Execute │        │    │
│    │    │  取指令  │    │  解碼   │    │   執行   │        │    │
│    │    └─────────┘    └─────────┘    └─────────┘        │    │
│    │         ↑                              │             │    │
│    │         └──────────────────────────────┘             │    │
│    │                    循環                              │    │
│    └──────────────────────────────────────────────────────┘    │
│                                                                 │
│    1. Fetch：從 PC 指向的位置讀取 opcode                        │
│    2. Decode：根據 opcode 找到對應的指令實現                     │
│    3. Execute：執行指令，可能修改棧、局部變量、PC                 │
│    4. 重複直到方法返回                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

<br>
<br>

## JVM 指令集設計哲學

**為什麼用單字節 Opcode？**

```
┌─────────────────────────────────────────────────────────────────┐
│  JVM 指令格式                                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌──────────┬──────────────────────────────────┐              │
│   │  Opcode  │         Operands (可選)           │              │
│   │  1 byte  │        0 ~ N bytes               │              │
│   └──────────┴──────────────────────────────────┘              │
│                                                                 │
│   例子：                                                        │
│   ┌──────┐                                                     │
│   │ 0x03 │                    iconst_0 (無操作數)               │
│   └──────┘                                                     │
│                                                                 │
│   ┌──────┬──────┐                                              │
│   │ 0x10 │  42  │              bipush 42 (1字節操作數)          │
│   └──────┴──────┘                                              │
│                                                                 │
│   ┌──────┬──────┬──────┐                                       │
│   │ 0x11 │ 0x01 │ 0x00 │       sipush 256 (2字節操作數)         │
│   └──────┴──────┴──────┘                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

為什麼？

* 1 byte = 256 種可能的 opcode
* JVM 實際用了約 200 個
* 指令緊湊，class 文件更小
* 網絡傳輸更快（過去在 Java Applet 流行的時代很重要）


<br>

## 指令命名規則

**JVM 指令名有規律可循：**

```
┌─────────────────────────────────────────────────────────────────┐
│  指令命名模式：<類型前綴><操作>                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  類型前綴：                                                      │
│  ┌─────┬───────────┐                                           │
│  │  i  │  int      │                                           │
│  │  l  │  long     │                                           │
│  │  f  │  float    │                                           │
│  │  d  │  double   │                                           │
│  │  a  │  reference│  (address)                                │
│  │  b  │  byte     │                                           │
│  │  c  │  char     │                                           │
│  │  s  │  short    │                                           │
│  └─────┴───────────┘                                           │
│                                                                 │
│  例子：                                                         │
│  iadd = int add      (整數加法)                                 │
│  ladd = long add     (長整數加法)                               │
│  fadd = float add    (浮點加法)                                 │
│  iload = int load    (載入整數到棧)                              │
│  aload = address load (載入引用到棧)                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

<br>
<br>

---

<br>
<br>

## ByteCodeReader - 字節碼讀取器

**設計背景：**

每個方法的 Code 屬性中包含字節碼（bytecode），解釋器需要按順序讀取這些字節碼並執行。

<br>

BytecodeReader 封裝了字節碼的讀取邏輯，提供：

* 讀取不同長度的數據（1, 2, 4 字節）
* 跟蹤當前讀取位置（PC）
* 支持跳轉（修改 PC）

<br>

與 ClassReader 的區別：

* ClassReader：讀取整個 .class 文件，只讀一次
* BytecodeReader：讀取方法的字節碼，可能來回跳轉

```
 ┌────────────────────────────────────────────────────────────┐
 │                    BytecodeReader                          │
 ├────────────────────────────────────────────────────────────┤
 │  code: [0x03, 0x3C, 0x04, 0x3D, 0x1B, 0x1C, 0x60, 0xAC]   │
 │                     ↑                                      │
 │                    pc=0                                    │
 │                                                            │
 │  ReadUint8() → 返回 0x03，pc 變成 1                         │
 │  ReadUint8() → 返回 0x3C，pc 變成 2                         │
 │  ...                                                       │
 └────────────────────────────────────────────────────────────┘
```
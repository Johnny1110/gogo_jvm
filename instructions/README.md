# Bytecode instructions 解釋器

<br>

---

<br>

## 解釋器的核心：Fetch-Decode-Execute 循環

```
┌─────────────────────────────────────────────────────────────────┐
│                    解釋器工作原理                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│    ┌──────────────────────────────────────────────────────┐    │
│    │                                                      │    │
│    │    ┌─────────┐    ┌─────────┐    ┌─────────┐        │    │
│    │    │  Fetch  │ →  │ Decode  │ →  │ Execute │        │    │
│    │    │  取指令  │    │  解碼   │    │   執行   │        │    │
│    │    └─────────┘    └─────────┘    └─────────┘        │    │
│    │         ↑                              │             │    │
│    │         └──────────────────────────────┘             │    │
│    │                    循環                              │    │
│    └──────────────────────────────────────────────────────┘    │
│                                                                 │
│    1. Fetch：從 PC 指向的位置讀取 opcode                        │
│    2. Decode：根據 opcode 找到對應的指令實現                     │
│    3. Execute：執行指令，可能修改棧、局部變量、PC                 │
│    4. 重複直到方法返回                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

<br>
<br>

## JVM 指令集設計哲學

**為什麼用單字節 Opcode？**

```
┌─────────────────────────────────────────────────────────────────┐
│  JVM 指令格式                                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌──────────┬──────────────────────────────────┐              │
│   │  Opcode  │         Operands (可選)           │              │
│   │  1 byte  │        0 ~ N bytes               │              │
│   └──────────┴──────────────────────────────────┘              │
│                                                                 │
│   例子：                                                        │
│   ┌──────┐                                                     │
│   │ 0x03 │                    iconst_0 (無操作數)               │
│   └──────┘                                                     │
│                                                                 │
│   ┌──────┬──────┐                                              │
│   │ 0x10 │  42  │              bipush 42 (1字節操作數)          │
│   └──────┴──────┘                                              │
│                                                                 │
│   ┌──────┬──────┬──────┐                                       │
│   │ 0x11 │ 0x01 │ 0x00 │       sipush 256 (2字節操作數)         │
│   └──────┴──────┴──────┘                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

為什麼？

* 1 byte = 256 種可能的 opcode
* JVM 實際用了約 200 個
* 指令緊湊，class 文件更小
* 網絡傳輸更快（過去在 Java Applet 流行的時代很重要）


<br>

## 指令命名規則

**JVM 指令名有規律可循：**

```
┌─────────────────────────────────────────────────────────────────┐
│  指令命名模式：<類型前綴><操作>                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  類型前綴：                                                      │
│  ┌─────┬───────────┐                                           │
│  │  i  │  int      │                                           │
│  │  l  │  long     │                                           │
│  │  f  │  float    │                                           │
│  │  d  │  double   │                                           │
│  │  a  │  reference│  (address)                                │
│  │  b  │  byte     │                                           │
│  │  c  │  char     │                                           │
│  │  s  │  short    │                                           │
│  └─────┴───────────┘                                           │
│                                                                 │
│  例子：                                                         │
│  iadd = int add      (整數加法)                                 │
│  ladd = long add     (長整數加法)                               │
│  fadd = float add    (浮點加法)                                 │
│  iload = int load    (載入整數到棧)                              │
│  aload = address load (載入引用到棧)                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

<br>
<br>

---

<br>
<br>

## ByteCodeReader - 字節碼讀取器

**設計背景：**

每個方法的 Code 屬性中包含字節碼（bytecode），解釋器需要按順序讀取這些字節碼並執行。

<br>

BytecodeReader 封裝了字節碼的讀取邏輯，提供：

* 讀取不同長度的數據（1, 2, 4 字節）
* 跟蹤當前讀取位置（PC）
* 支持跳轉（修改 PC）

<br>

與 ClassReader 的區別：

* ClassReader：讀取整個 .class 文件，只讀一次
* BytecodeReader：讀取方法的字節碼，可能來回跳轉

```
 ┌────────────────────────────────────────────────────────────┐
 │                    BytecodeReader                          │
 ├────────────────────────────────────────────────────────────┤
 │  code: [0x03, 0x3C, 0x04, 0x3D, 0x1B, 0x1C, 0x60, 0xAC]   │
 │                     ↑                                      │
 │                    pc=0                                    │
 │                                                            │
 │  ReadUint8() → 返回 0x03，pc 變成 1                         │
 │  ReadUint8() → 返回 0x3C，pc 變成 2                         │
 │  ...                                                       │
 └────────────────────────────────────────────────────────────┘
```

<br>
<br>

## Instruction 指令接口

**設計背景：**

這是 JVM 指令的抽象表示。每一條 JVM 指令都需要實現這個接口。

* FetchOperands：負責「讀取」（從字節碼讀操作數）
* Execute：負責「執行」（操作棧和局部變量）

**解釋器的工作流程：**

```
for {                                                      
    pc := frame.NextPC()                                   
    reader.SetPC(pc)                                       
                                                              
    opcode := reader.ReadUint8()       1. 讀取 opcode       
    inst := decodeInstruction(opcode)  2. 解碼得到指令       
    inst.FetchOperands(reader)         3. 讀取操作數         
    inst.Execute(frame)                4. 執行指令          
}  
```

<br>
<br>

## 建立一些基礎指令 - Const (把 Const PUSH 到 Stack)

<br>

### CONST 指令

把一些常用的 int (-1~5) long, float double 壓入 Stack 時使用。

<br>

### IPUSH 指令

使用 CONST 無法滿足時，可以使用 `BIPUSH` 和 `SIPUSH`

* `BIPUSH`: Byte Immediate PUSH
  - 操作數是 1 byte 有符號數
  - 範圍：-128 ~ 127

* `SIPUSH`: Short Immediate PUSH
  - 操作數是 2 bytes 有符號數
  - 範圍：-32768 ~ 32767

舉例：
```java
int a = 100;     編譯成 bipush 100
int b = 1000;    編譯成 sipush 1000
int c = 100000;  編譯成 ldc（從常量池載入）
```

<br>

### LOAD 指令

JVM 中最常用的指令之一

**工作原理：**

把值從局部變量表複製一份放入 Stack
```
 ┌─────────────────────────────────────────────────────────┐
 │  局部變量表                    操作數棧                   │
 │  ┌─────┬─────┬─────┐         ┌─────┐                   │
 │  │  5  │ 10  │ 15  │         │     │                   │
 │  └─────┴─────┴─────┘         └─────┘                   │
 │    [0]   [1]   [2]                                     │
 │                                                        │
 │  執行 iload_1 後：                                      │
 │  ┌─────┬─────┬─────┐         ┌─────┐                   │
 │  │  5  │ 10  │ 15  │         │ 10  │ ← 從 [1] 複製     │
 │  └─────┴─────┴─────┘         └─────┘                   │
 │    [0]   [1]   [2]                                     │
 │                                                        │
 │  注意：局部變量表的值不變（是複製，不是移動）                 │
 └─────────────────────────────────────────────────────────┘
```

<br>


### STORE 指令

**工作原理：**

把值從 stack 移動到 LocalVars 中

```
 ┌─────────────────────────────────────────────────────────┐
 │  局部變量表                    操作數棧                  │
 │  ┌─────┬─────┬─────┐         ┌─────┐                   │
 │  │  5  │  ?  │  ?  │         │ 42  │ ← 棧頂             │
 │  └─────┴─────┴─────┘         └─────┘                   │
 │    [0]   [1]   [2]                                     │
 │                                                        │
 │  執行 istore_1 後：                                      │
 │  ┌─────┬─────┬─────┐         ┌─────┐                   │
 │  │  5  │ 42  │  ?  │         │     │ ← 棧變空          │
 │  └─────┴─────┴─────┘         └─────┘                   │
 │    [0]   [1]   [2]                                     │
 │              ↑                                         │
 │             新值                                        │
 └─────────────────────────────────────────────────────────┘
```
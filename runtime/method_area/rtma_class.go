package method_area

import (
	"fmt"
	"github.com/Johnny1110/gogo_jvm/classfile"
	"github.com/Johnny1110/gogo_jvm/common"
	"github.com/Johnny1110/gogo_jvm/runtime/heap"
	"github.com/Johnny1110/gogo_jvm/runtime/rtcore"
	"strings"
)

// Class instant in runtime method area
//
// ClassFile（Compile）   →    Class（Runtime）
// ┌─────────────────┐        ┌─────────────────┐
// │ constantPool    │   →    │ constantPool    │  RuntimeConstantPool
// │ accessFlags     │   →    │ accessFlags     │
// │ thisClass       │   →    │ name            │  class name
// │ superClass      │   →    │ superClass      │  ref to super Class
// │ interfaces      │   →    │ interfaces      │  ref to interface Class[]
// │ fields          │   →    │ fields          │  runtime fields
// │ methods         │   →    │ methods         │  runtime methods
// └─────────────────┘        └─────────────────┘
//
// v0.3.1: add jClass column -> implement image design pattern
type Class struct {
	accessFlags       uint16
	name              string // className (ex: java/lang/Object)
	superClassName    string
	interfaceNames    []string
	constantPool      *RuntimeConstantPool // ConstantPool Runtime
	fields            []*Field
	methods           []*Method
	loader            *ClassLoader // 加載此類的 ClassLoader
	superClass        *Class       // parent class ref
	interfaces        []*Class     // interface refs
	instanceSlotCount uint         // 實例變量佔用的 slot 數量
	staticSlotCount   uint         // 類變量佔用的 slot 數量
	staticVars        rtcore.Slots // class's static vars

	// initStarted mark is this class already starting init, make sure <clinit> only do once
	// usage:
	// - `new` create Object
	// - getstatic/putstatic access static fields
	// - invokestatic call static method
	// - 子類初始化時（父類需先初始化）
	initStarted bool

	// v0.3.1: JClass - Reflection Support (Mirror Design Pattern)
	// jClass pointing to Java's java.lang.Class Object, allow user to using obj.getClass()
	// Mirror Relationship:
	// method_area.Class.jClass → heap.Object (java.lang.Class Instance)
	// heap.Object.extra → method_area.Class (pointing back)
	jClass *heap.Object
	// v0.3.1: ArrayType dedicated (element's type)
	// ex - 1: int[] componentClass is int Class
	// ex - 2: String[][] componentClass is String[] Class
	componentClass *Class
}

// newClass create Class from classfile.ClassFile
func newClass(cf *classfile.ClassFile) *Class {
	c := &Class{}
	c.accessFlags = cf.AccessFlags()
	c.name = cf.ClassName()
	c.superClassName = cf.SuperClassName()
	c.interfaceNames = cf.InterfaceNames()
	c.constantPool = newRuntimeConstantPool(c, cf.ConstantPool())
	c.fields = newFields(c, cf.Fields())
	c.methods = newMethods(c, cf.Methods())
	return c
}

// =============== Object Creation ===============

// NewObject create Object by this Class
// only allocate memory and setup default value, not exec constructor
// the constructor will be called by invokespecial <init>
//
// ex:
//
//	new Counter  →  class.NewObject()
//	               return a Object with all default fields value
//
// Memory：
//
//	Object.fields size = class.instanceSlotCount (including parent's)
func (c *Class) NewObject() *heap.Object {
	return heap.NewObject(c, c.instanceSlotCount)
}

// =============== Class Initialization ===============

// InitStarted check init is start or not
func (c *Class) InitStarted() bool {
	return c.initStarted
}

// StartInit mark init
// should be called before <clinit>
func (c *Class) StartInit() {
	c.initStarted = true
}

// GetClinitMethod get class init method <clinit>
// return nil if  <clinit> not found
// <clinit> will be generated by compiler
// Usage:
// - init static vars
// - execute static { ... }
func (c *Class) GetClinitMethod() *Method {
	return c.getStaticMethod("<clinit>", "()V")
}

// =============== Getters ===============

func (c *Class) Name() string                       { return c.name }
func (c *Class) SuperClassName() string             { return c.superClassName }
func (c *Class) InterfaceNames() []string           { return c.interfaceNames }
func (c *Class) ConstantPool() *RuntimeConstantPool { return c.constantPool }
func (c *Class) Fields() []*Field                   { return c.fields }
func (c *Class) Methods() []*Method                 { return c.methods }
func (c *Class) Loader() *ClassLoader               { return c.loader }
func (c *Class) SuperClass() *Class                 { return c.superClass }
func (c *Class) StaticVars() rtcore.Slots           { return c.staticVars }
func (c *Class) AccessFlags() uint16                { return c.accessFlags }
func (c *Class) InstanceSlotCount() uint            { return c.instanceSlotCount }
func (c *Class) Interfaces() []*Class {
	return c.interfaces
}

// =============== Reflection Support - Getter & Setter (v0.3.1) ===============

func (c *Class) JClass() *heap.Object {
	return c.jClass
}

func (c *Class) SetJClass(jc *heap.Object) {
	c.jClass = jc
}

func (c *Class) ComponentClass() *Class {
	return c.componentClass
}

func (c *Class) SetComponentClass(componentClass *Class) {
	c.componentClass = componentClass
}

// =============== Type Checking for Reflection (v0.3.1) ===============

// IsPrimitive check is basic type
// basic type don't have class file, they are native in JVM
func (c *Class) IsPrimitive() bool {
	switch c.name {
	case "void", "boolean", "byte", "char", "int", "short", "long", "float", "double":
		return true
	}
	return false
}

// IsArray check is array type
// array type name start with "[", ex: "[I", "[Ljava/lang/String;"
func (c *Class) IsArray() bool {
	return len(c.name) > 0 && c.name[0] == '['
}

// JavaName get class's java name
// JVM using "/" to split pkg, Java using "." to split pkg
// ex: java/lang/String → java.lang.String
// edge case:
// - 1. Array keep the same: [I, [Ljava/lang/String;
// - 2. basic type keep the same: int, void
func (c *Class) JavaName() string {
	if c.IsPrimitive() {
		return c.name
	}

	if c.IsArray() {
		return c.getArrayJavaName()
	}

	return strings.ReplaceAll(c.name, "/", ".")
}

// getArrayJavaName
// [I → [I
// [Ljava/lang/String; → [Ljava.lang.String;
func (c *Class) getArrayJavaName() string {
	name := c.name
	result := strings.Builder{}

	for i := 0; i < len(name); i++ {
		ch := name[i]
		if ch == 'L' { // found a Class
			result.WriteByte('L')
			i++
			// start convert "/" to "."
			for i < len(name) && name[i] != ';' {
				if name[i] == '/' {
					result.WriteByte('.')
				} else {
					result.WriteByte(name[i])
				}
				i++
			}

			if i < len(name) {
				result.WriteByte(';')
			}
		} else {
			// is basic type
			result.WriteByte(ch)
		}
	}

	return result.String()
}

// GetArrayClass
// ex: String → String[], int → int[]
// this is for support Array.newInstance()
func (c *Class) GetArrayClass() *Class {
	arrayClassName := getArrayClassName(c.name)
	return c.loader.LoadClass(arrayClassName, false)
}

// getArrayClassName generate array class name according to element's name
// int -> [I
// java/lang/String → [Ljava/lang/String;
// [I → [[I
func getArrayClassName(className string) string {
	if len(className) > 0 && className[0] == '[' {
		return "[" + className
	}

	// basic type
	switch className {
	case "void":
		panic("cannot create array of void")
	case "boolean":
		return "[Z"
	case "byte":
		return "[B"
	case "char":
		return "[C"
	case "short":
		return "[S"
	case "int":
		return "[I"
	case "long":
		return "[J"
	case "float":
		return "[F"
	case "double":
		return "[D"
	default:
		// Ref Type
		return "[L" + className + ";"
	}
}

// GetComponentClassName get element name according to ArrayClassName
// [I → int
// [Ljava/lang/String; → java/lang/String
// [[I → [I
func GetComponentClassName(arrayClassName string) string {
	if len(arrayClassName) < 2 || arrayClassName[0] != '[' {
		panic("not an array class: " + arrayClassName)
	}

	componentDescriptor := arrayClassName[1:]

	switch componentDescriptor[0] {
	case '[':
		// Multidimensional array, return sub array type
		return componentDescriptor
	case 'L':
		// Ref Type, remove 'L' and ';' (first and last)
		return componentDescriptor[1 : len(componentDescriptor)-1]
	case 'Z':
		return "boolean"
	case 'B':
		return "byte"
	case 'C':
		return "char"
	case 'S':
		return "short"
	case 'I':
		return "int"
	case 'J':
		return "long"
	case 'F':
		return "float"
	case 'D':
		return "double"
	default:
		panic("invalid array descriptor: " + arrayClassName)
	}
}

// =============== Access Flags ===============

func (c *Class) IsPublic() bool     { return c.accessFlags&common.ACC_PUBLIC != 0 }
func (c *Class) IsFinal() bool      { return c.accessFlags&common.ACC_FINAL != 0 }
func (c *Class) IsSuper() bool      { return c.accessFlags&common.ACC_SUPER != 0 }
func (c *Class) IsInterface() bool  { return c.accessFlags&common.ACC_INTERFACE != 0 }
func (c *Class) IsAbstract() bool   { return c.accessFlags&common.ACC_ABSTRACT != 0 }
func (c *Class) IsSynthetic() bool  { return c.accessFlags&common.ACC_SYNTHETIC != 0 }
func (c *Class) IsAnnotation() bool { return c.accessFlags&common.ACC_ANNOTATION != 0 }
func (c *Class) IsEnum() bool       { return c.accessFlags&common.ACC_ENUM != 0 }

// =============== Method Lookup ===============

// GetMainMethod get `public static void main([]String args) {}`
func (c *Class) GetMainMethod() *Method {
	return c.getStaticMethod("main", "([Ljava/lang/String;)V")
}

// getStaticMethod get static method
func (c *Class) getStaticMethod(name, descriptor string) *Method {
	for _, method := range c.methods {
		if method.IsStatic() && method.name == name && method.descriptor == descriptor {
			return method
		}
	}
	return nil
}

// GetMethod get method (including parent and grandparent...)
func (c *Class) GetMethod(name, descriptor string) *Method {
	// try to find in current class
	for _, method := range c.methods {
		if method.name == name && method.descriptor == descriptor {
			return method
		}
	}

	// try to find in parent and grandparent...
	if c.superClass != nil {
		return c.superClass.GetMethod(name, descriptor)
	}

	return nil
}

func (c *Class) GetStaticMethod(name, descriptor string) *Method {
	return c.getStaticMethod(name, descriptor)
}

// =============== Field Lookup ===============

// GetField
// Usage: getfield/putfield/getstatic/putstatic
func (c *Class) GetField(name, descriptor string, isStatic bool) *Field {
	for _, field := range c.fields {
		if field.IsStatic() == isStatic &&
			field.name == name &&
			field.descriptor == descriptor {
			return field
		}
	}

	if c.superClass != nil {
		return c.superClass.GetField(name, descriptor, isStatic)
	}

	return nil
}

// =============== Type Checking ===============

// IsAssignableFrom 檢查 other 是否可以賦值給 this
// ex: this = other is legal or not
// Rules：
// 1. same class: true
// 2. other is this subclass: true
// 3. this is interface, other implements this: true
func (c *Class) IsAssignableFrom(other *Class) bool {
	if c == other {
		return true
	}

	if !c.IsInterface() {
		return other.IsSubClassOf(c)
	}

	return other.IsImplements(c)
}

// IsSubClassOf check this class is target's subclass
func (c *Class) IsSubClassOf(target *Class) bool {
	for super := c.superClass; super != nil; super = super.superClass {
		if super == target {
			return true
		}
	}
	return false
}

// IsImplements check is this  class implements target
func (c *Class) IsImplements(target *Class) bool {

	for _, iface := range c.interfaces {
		if iface == target || iface.IsSubInterfaceOf(target) {
			return true
		}
	}

	if c.superClass != nil {
		return c.superClass.IsImplements(target)
	}

	return false
}

// IsSubInterfaceOf
func (c *Class) IsSubInterfaceOf(target *Class) bool {
	for _, superInterface := range c.interfaces {
		if superInterface == target || superInterface.IsSubInterfaceOf(target) {
			return true
		}
	}
	return false
}

// IsSuperClassOf
func (c *Class) IsSuperClassOf(other *Class) bool {
	return other.IsSubClassOf(c)
}

// String for debug display
func (c *Class) String() string {
	if c == nil {
		return "<nil Class>"
	}

	var sb strings.Builder

	// Header with class name
	sb.WriteString("Class { ")
	sb.WriteString(fmt.Sprintf("  Name: %s ", c.name))

	// Access flags (human readable)
	sb.WriteString(fmt.Sprintf("  Access: %s ", c.accessFlagsString()))

	// Inheritance hierarchy
	if c.superClassName != "" {
		sb.WriteString(fmt.Sprintf("  Extends: %s ", c.superClassName))
		if c.superClass != nil {
			sb.WriteString(" ✓")
		}
		sb.WriteString("\n")
	}

	// Interfaces
	if len(c.interfaceNames) > 0 {
		sb.WriteString(fmt.Sprintf("  Implements: %d interface(s)", len(c.interfaceNames)))
		if len(c.interfaces) == len(c.interfaceNames) {
			sb.WriteString(" ✓")
		}
		sb.WriteString("\n")
		for i, name := range c.interfaceNames {
			if i >= 3 { // 只顯示前 3 個
				sb.WriteString(fmt.Sprintf("    ... and %d more ", len(c.interfaceNames)-3))
				break
			}
			sb.WriteString(fmt.Sprintf("    - %s\n", name))
		}
	}

	// Fields and Methods summary
	sb.WriteString(fmt.Sprintf("  \t\t\t Fields:  %d (instance slots: %d, static slots: %d) \n",
		len(c.fields), c.instanceSlotCount, c.staticSlotCount))

	sb.WriteString(fmt.Sprintf("    \t\t\t Methods: %d ", len(c.methods)))
	if len(c.methods) > 0 && len(c.methods) <= 5 {
		for _, method := range c.methods {
			sb.WriteString(fmt.Sprintf(" - %s ", method.Name()))
		}
	} else if len(c.methods) > 5 {
		for i := 0; i < 3; i++ {
			sb.WriteString(fmt.Sprintf(" - %s ", c.methods[i].Name()))
		}
		sb.WriteString(fmt.Sprintf("    ... and %d more ", len(c.methods)-3))
	}

	// Runtime status
	sb.WriteString(fmt.Sprintf("  Constant Pool: %v ", c.constantPool != nil))
	sb.WriteString(fmt.Sprintf("  Loader: %v ", c.loader != nil))
	sb.WriteString(fmt.Sprintf("  Init Started: %v ", c.initStarted))

	sb.WriteString("}")

	return sb.String()
}

func (c *Class) accessFlagsString() string {
	flags := []string{}

	if c.accessFlags&common.ACC_PUBLIC != 0 {
		flags = append(flags, "public")
	}
	if c.accessFlags&common.ACC_FINAL != 0 {
		flags = append(flags, "final")
	}
	if c.accessFlags&common.ACC_SUPER != 0 {
		flags = append(flags, "super")
	}
	if c.accessFlags&common.ACC_INTERFACE != 0 {
		flags = append(flags, "interface")
	}
	if c.accessFlags&common.ACC_ABSTRACT != 0 {
		flags = append(flags, "abstract")
	}
	if c.accessFlags&common.ACC_SYNTHETIC != 0 {
		flags = append(flags, "synthetic")
	}
	if c.accessFlags&common.ACC_ANNOTATION != 0 {
		flags = append(flags, "annotation")
	}
	if c.accessFlags&common.ACC_ENUM != 0 {
		flags = append(flags, "enum")
	}

	if len(flags) == 0 {
		return fmt.Sprintf("0x%04x", c.accessFlags)
	}

	return fmt.Sprintf("%s (0x%04x)", strings.Join(flags, " "), c.accessFlags)
}

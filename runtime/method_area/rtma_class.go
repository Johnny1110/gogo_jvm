package method_area

import (
	"github.com/Johnny1110/gogo_jvm/classfile"
	"github.com/Johnny1110/gogo_jvm/common"
	"github.com/Johnny1110/gogo_jvm/runtime/heap"
	"github.com/Johnny1110/gogo_jvm/runtime/rtcore"
)

// Class instant in runtime method area
//
// ClassFile（Compile）   →    Class（Runtime）
// ┌─────────────────┐        ┌─────────────────┐
// │ constantPool    │   →    │ constantPool    │  RuntimeConstantPool
// │ accessFlags     │   →    │ accessFlags     │
// │ thisClass       │   →    │ name            │  class name
// │ superClass      │   →    │ superClass      │  ref to super Class
// │ interfaces      │   →    │ interfaces      │  ref to interface Class[]
// │ fields          │   →    │ fields          │  runtime fields
// │ methods         │   →    │ methods         │  runtime methods
// └─────────────────┘        └─────────────────┘
type Class struct {
	accessFlags       uint16
	name              string // className (ex: java/lang/Object)
	superClassName    string
	interfaceNames    []string
	constantPool      *RuntimeConstantPool // ConstantPool Runtime
	fields            []*Field
	methods           []*Method
	loader            *ClassLoader // 加載此類的 ClassLoader
	superClass        *Class       // parent class ref
	interfaces        []*Class     // interface refs
	instanceSlotCount uint         // 實例變量佔用的 slot 數量
	staticSlotCount   uint         // 類變量佔用的 slot 數量
	staticVars        rtcore.Slots // class's static vars

	// initStarted mark is this class already starting init, make sure <clinit> only do once
	// usage:
	// - `new` create Object
	// - getstatic/putstatic access static fields
	// - invokestatic call static method
	// - 子類初始化時（父類需先初始化）
	initStarted bool
}

// newClass create Class from classfile.ClassFile
func newClass(cf *classfile.ClassFile) *Class {
	c := &Class{}
	c.accessFlags = cf.AccessFlags()
	c.name = cf.ClassName()
	c.superClassName = cf.SuperClassName()
	c.interfaceNames = cf.InterfaceNames()
	c.constantPool = newRuntimeConstantPool(c, cf.ConstantPool())
	c.fields = newFields(c, cf.Fields())
	c.methods = newMethods(c, cf.Methods())
	return c
}

// =============== Object Creation ===============

// NewObject create Object by this Class
// only allocate memory and setup default value, not exec constructor
// the constructor will be called by invokespecial <init>
//
// ex:
//
//	new Counter  →  class.NewObject()
//	               return a Object with all default fields value
//
// Memory：
//
//	Object.fields size = class.instanceSlotCount (including parent's)
func (c *Class) NewObject() *heap.Object {
	return heap.NewObject(c, c.instanceSlotCount)
}

// =============== Class Initialization ===============

// InitStarted check init is start or not
func (c *Class) InitStarted() bool {
	return c.initStarted
}

// StartInit mark init
// should be called before <clinit>
func (c *Class) StartInit() {
	c.initStarted = true
}

// GetClinitMethod get class init method <clinit>
// return nil if  <clinit> not found
// <clinit> will be generated by compiler
// Usage:
// - init static vars
// - execute static { ... }
func (c *Class) GetClinitMethod() *Method {
	return c.getStaticMethod("<clinit>", "()V")
}

// =============== Getters ===============

func (c *Class) Name() string                       { return c.name }
func (c *Class) SuperClassName() string             { return c.superClassName }
func (c *Class) InterfaceNames() []string           { return c.interfaceNames }
func (c *Class) ConstantPool() *RuntimeConstantPool { return c.constantPool }
func (c *Class) Fields() []*Field                   { return c.fields }
func (c *Class) Methods() []*Method                 { return c.methods }
func (c *Class) Loader() *ClassLoader               { return c.loader }
func (c *Class) SuperClass() *Class                 { return c.superClass }
func (c *Class) StaticVars() rtcore.Slots           { return c.staticVars }
func (c *Class) AccessFlags() uint16                { return c.accessFlags }
func (c *Class) InstanceSlotCount() uint            { return c.instanceSlotCount }

// =============== Access Flags ===============

func (c *Class) IsPublic() bool     { return c.accessFlags&common.ACC_PUBLIC != 0 }
func (c *Class) IsFinal() bool      { return c.accessFlags&common.ACC_FINAL != 0 }
func (c *Class) IsSuper() bool      { return c.accessFlags&common.ACC_SUPER != 0 }
func (c *Class) IsInterface() bool  { return c.accessFlags&common.ACC_INTERFACE != 0 }
func (c *Class) IsAbstract() bool   { return c.accessFlags&common.ACC_ABSTRACT != 0 }
func (c *Class) IsSynthetic() bool  { return c.accessFlags&common.ACC_SYNTHETIC != 0 }
func (c *Class) IsAnnotation() bool { return c.accessFlags&common.ACC_ANNOTATION != 0 }
func (c *Class) IsEnum() bool       { return c.accessFlags&common.ACC_ENUM != 0 }

// =============== Method Lookup ===============

// GetMainMethod get `public static void main([]String args) {}`
func (c *Class) GetMainMethod() *Method {
	return c.getStaticMethod("main", "([Ljava/lang/String;)V")
}

// getStaticMethod get static method
func (c *Class) getStaticMethod(name, descriptor string) *Method {
	for _, method := range c.methods {
		if method.IsStatic() && method.name == name && method.descriptor == descriptor {
			return method
		}
	}
	return nil
}

// GetMethod get method (including parent and grandparent...)
func (c *Class) GetMethod(name, descriptor string) *Method {
	// try to find in current class
	for _, method := range c.methods {
		if method.name == name && method.descriptor == descriptor {
			return method
		}
	}

	// try to find in parent and grandparent...
	if c.superClass != nil {
		return c.superClass.GetMethod(name, descriptor)
	}

	return nil
}

func (c *Class) GetStaticMethod(name, descriptor string) *Method {
	return c.getStaticMethod(name, descriptor)
}

// =============== Field Lookup ===============

// GetField
// Usage: getfield/putfield/getstatic/putstatic
func (c *Class) GetField(name, descriptor string, isStatic bool) *Field {
	for _, field := range c.fields {
		if field.IsStatic() == isStatic &&
			field.name == name &&
			field.descriptor == descriptor {
			return field
		}
	}

	if c.superClass != nil {
		return c.superClass.GetField(name, descriptor, isStatic)
	}

	return nil
}

// =============== Type Checking ===============

// IsAssignableFrom 檢查 other 是否可以賦值給 this
// ex: this = other is legal or not
// Rules：
// 1. same clas: true
// 2. other is this subclass: true
// 3. this is interface, other implements this: true
func (c *Class) IsAssignableFrom(other *Class) bool {
	if c == other {
		return true
	}

	if !c.IsInterface() {
		return other.IsSubClassOf(c)
	}

	return other.IsImplements(c)
}

// IsSubClassOf check this class is target's subclass
func (c *Class) IsSubClassOf(target *Class) bool {
	for super := c.superClass; super != nil; super = super.superClass {
		if super == target {
			return true
		}
	}
	return false
}

// IsImplements check is this  class implements target
func (c *Class) IsImplements(target *Class) bool {

	for _, iface := range c.interfaces {
		if iface == target || iface.IsSubInterfaceOf(target) {
			return true
		}
	}

	if c.superClass != nil {
		return c.superClass.IsImplements(target)
	}

	return false
}

// IsSubInterfaceOf
func (c *Class) IsSubInterfaceOf(target *Class) bool {
	for _, superInterface := range c.interfaces {
		if superInterface == target || superInterface.IsSubInterfaceOf(target) {
			return true
		}
	}
	return false
}

// IsSuperClassOf
func (c *Class) IsSuperClassOf(other *Class) bool {
	return other.IsSubClassOf(c)
}

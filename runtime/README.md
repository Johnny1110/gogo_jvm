# Runtime data areas (WIP)

<br>

---

<br>

## JVM Stack-based Architecture（基於棧的架構）：

```
┌────────────────────────────────────────────────────────────────┐
│                    JVM Runtime Data Areas                       │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐     ┌─────────────────────────────────┐   │
│  │   PC Register   │     │           Heap (堆)              │   │
│  │  (程式計數器)    │     │      所有對象實例都在這裡         │   │
│  │   每線程一個     │     │        所有線程共享              │   │
│  └─────────────────┘     └─────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────┐     ┌─────────────────────────────────┐   │
│  │   JVM Stack     │     │       Method Area (方法區)       │   │
│  │  (虛擬機棧)      │     │     類信息、常量池、方法代碼      │   │
│  │   每線程一個     │     │        所有線程共享              │   │
│  └─────────────────┘     └─────────────────────────────────┘   │
│          │                                                      │
│          ▼                                                      │
│  ┌─────────────────┐                                           │
│  │     Frame       │  ← 每個方法調用創建一個棧幀               │
│  │   ┌─────────┐   │                                           │
│  │   │ LocalVar│   │  ← 局部變量表                             │
│  │   └─────────┘   │                                           │
│  │   ┌─────────┐   │                                           │
│  │   │ OpStack │   │  ← 操作數棧                               │
│  │   └─────────┘   │                                           │
│  └─────────────────┘                                           │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

<br>

### 為什麼選擇 Stack-based 而非 Register-based？

Stack-based（JVM） vs Register-based（Dalvik/CPU）特性比較:

| 特性               | Stack-based（JVM）                     | Register-based（Dalvik / 實體 CPU）        |
|--------------------|-----------------------------------------|---------------------------------------------|
| 指令大小           | 更小（1–3 bytes）                       | 更大（需要指定寄存器）                      |
| 可移植性           | 極佳（不依賴硬體寄存器數量）            | 依賴硬體設計，較不具可移植性                |
| 實作難度           | 較簡單                                   | 較複雜（需管理寄存器配置）                  |
| 執行效率           | 較慢（需要更多 push/pop 記憶體操作）    | 較快（寄存器直接運算）                      |

<br>

Java 的目標是 "Write Once, Run Anywhere"，所以選擇了可移植性更好的 Stack-based 架構。

<br>
<br>

**實作順序：**

```
runtime/
├── thread.go           # 1. 線程（持有 PC 和 Stack）
├── jvm_stack.go        # 2. 虛擬機棧（持有多個 Frame）
├── frame.go            # 3. 棧幀（方法執行的環境）
├── local_vars.go       # 4. 局部變量表
├── operand_stack.go    # 5. 操作數棧
└── slot.go             # 6. 槽位（統一的數據單元） -> 32-bit 基本數據單元
```

<br>
<br>

---

<br>
<br>

## 核心概念

<br>

###  1. Slot (槽位）

**JVM 需要一個統一的方式來存儲不同類型的數據。**

問題：如何用統一的結構存儲 int, float, reference?

解決方案：Slot（32-bit 槽位）

```
  ┌──────────┐                                       
  │   Slot   │  = 32 bits                           
  └──────────┘                                       
       │                                             
       ├── int       → 1 個 slot                       
       ├── float     → 1 個 slot                       
       ├── reference → 1 個 slot（指標）              
       ├── long      → 2 個 slots（64-bit）            
       └── double    → 2 個 slots（64-bit）            
```

<br>

**設計思想：**

* JVM 規範定義局部變量表和操作數棧都是由「槽位」(Slot) 組成的。
* 每個 Slot 可以存放一個 32-bit 的數據。
* 對於 64-bit 的數據（long, double），需要連續的兩個 Slot。

<br>

**為什麼這樣設計？**

* 統一性：不管是 int、float 還是對象引用，都用同樣的結構存儲
* 簡單性：JVM 實現者只需處理一種基本單元
* 對齊性：32-bit 是當時（1995年）最常見的字長

<br>

**為什麼 long 和 double 要佔兩個 slot？**

這是歷史原因：JVM 設計於 1995 年，當時：
* 主流 CPU 是 32-bit
* 32-bit 操作比 64-bit 快
* 記憶體對齊以 32-bit 為單位最有效率

所以 JVM 規範規定：
* long/double 存入時，佔據 slot[n] 和 slot[n+1]
* 讀取時，必須從 slot[n] 開始讀兩個 slot
* slot[n+1] 不能單獨使用（規範要求）

<br>
<br>

###  2. LocalVars (局部變量表）

**設計背景：**

當 JVM 執行一個方法時，需要一個地方存放：

1. 方法參數
2. 方法內部的局部變量

這就是 LocalVars（局部變量表）的作用。

<br>

**重要特性：**

* 表的大小在編譯期就確定了（存在 Code Attribute 的 max_locals 中）
* 通過索引訪問（不是棧，是數組）
* 索引從 0 開始

<br>

**對於物件方法（非 static）：**

* slot[0] 固定存放 this 引用
* slot[1...] 存放參數和局部變量

**對於靜態方法（static）：**

* slot[0...] 直接存放參數和局部變量

<br>

舉例：

```java
public void foo(int a, long b, String c) {
     int d = 0;
}
```

局部變量表佈局：

```
注：long b 佔用了 slot2 和 slot3 兩個
┌───────┬───────┬───────┬───────┬───────┬───────┐
│ slot0 │ slot1 │ slot2 │ slot3 │ slot4 │ slot5 │
│ this  │   a   │ b(低) │  b(高) │   c   │   d   │
└───────┴───────┴───────┴───────┴───────┴───────┘
```

<br>
<br>

###  3. OperandStack (操作數棧）

**設計哲學：**

JVM 是「基於棧」的虛擬機，幾乎所有操作都通過操作數棧完成。

<br>

舉例：計算 `a + b`

* 基於寄存器的方式（x86）：
```
mov eax, a      ; 把 a 載入寄存器 eax
add eax, b      ; eax = eax + b
mov result, eax ; 把結果存回內存
```


* 基於棧的方式（JVM）：
```
iload_0    ; 把局部變量 0（a）壓入棧
iload_1    ; 把局部變量 1（b）壓入棧
iadd       ; 彈出兩個值，相加，把結果壓入棧
istore_2   ; 彈出棧頂，存入局部變量 2（result）
```

<br>

為什麼這樣設計？

1. 指令更簡短（不需要指定寄存器）
2. 實現更簡單（只需 push/pop）
3. 更容易驗證（棧的大小可預測）

操作數棧的大小（maxStack）是編譯期確定的，存在 Code 屬性中。編譯器會分析代碼，計算最大棧深度。

<br>
<br>

### 4. Frame (棧幀)

每當 JVM 調用一個方法時，就會創建一個新的棧幀（Frame）。 棧幀是方法執行的「環境」或「上下文」。


**為什麼需要棧幀？**

想像遞歸調用 factorial(5)：

```
actorial(5) -> factorial(4) -> factorial(3) ...
```

**每一層調用都需要自己的：**

* 局部變量（參數 n 的值不同）
* 操作數棧（計算中間運算結果）
* 返回地址（知道返回到哪裡繼續執行）

棧幀就是用來保存這些信息的。

<br>

**棧幀的生命週期：**

1. 方法被調用 → 創建新棧幀，壓入 JVM Stack
2. 方法執行中 → 棧幀是「當前幀」
3. 方法返回 → 棧幀彈出，銷毀

<br>

**棧幀結構：**

```
┌────────────────────────────────────────┐
│              Frame                     │
├────────────────────────────────────────┤
│  lower (指向下一幀，形成鏈表)             │
├────────────────────────────────────────┤
│  localVars (局部變量表)                  │
│  ┌─────┬─────┬─────┬─────┬─────┐       │
│  │  0  │  1  │  2  │  3  │ ... │       │
│  └─────┴─────┴─────┴─────┴─────┘       │
├────────────────────────────────────────┤
│  operandStack (操作數棧)                │
│  ┌─────┐                               │
│  │ top │ ← 棧頂                         │
│  ├─────┤                               │
│  │     │                               │
│  └─────┘                               │
├────────────────────────────────────────┤
│  thread (所屬線程的引用)                 │
├────────────────────────────────────────┤
│  nextPC (下一條要執行的指令地址)          │
└────────────────────────────────────────┘
```

<br>

設計考量（為未來擴展預留）：

* method: 後續會加入方法引用，用於獲取類信息、常量池等
* thread: 用於多線程支持和棧溢出檢測
* lower: 用鏈表而非數組，方便動態增長和異常處理時的棧展開

<br>
<br>

### 5. JVMStack 虛擬機棧（也叫 Java Stack）

**設計背景：**

* 每個 JVM 線程都有自己的 JVM Stack。
* JVM Stack 存放該線程執行過程中的所有棧幀。

<br>

**為什麼每個線程需要獨立的棧？**
1. 線程隔離：一個線程不應該訪問另一個線程的局部變量
2. 併發安全：每個線程有自己的執行狀態
3. 遞歸支持：同一個方法可以同時存在多個棧幀

<br>

**VM Stack 的工作方式：**

舉例：`調用 main() → 調用 foo() → 調用 bar()`

<br>

```
 ┌──────────────────┐
 │   bar() frame    │ ← 當前幀（棧頂）
 ├──────────────────┤
 │   foo() frame    │
 ├──────────────────┤
 │   main() frame   │
 ├──────────────────┤
 │       ...        │
 └──────────────────┘
``` 

bar() 返回後：

```
 反回後 bar() 的 Frame 就被銷毀了
 ┌──────────────────┐
 │   foo() frame    │ ← 當前幀
 ├──────────────────┤
 │   main() frame   │
 ├──────────────────┤
 │       ...        │
 └──────────────────┘
```

<br>

**StackOverflowError：**

JVM 規範允許限制棧的大小。當棧幀數量超過限制時， 應該拋出 java.lang.StackOverflowError。

這通常發生在：

* 無限遞歸
* 遞歸太深

<br>
<br>

### 6. Thread

**JVM 與線程的關係：**

* JVM 是一個多線程的虛擬機。每個 Java 線程對應一個 Thread 結構。

<br>

**線程私有的數據：**

1. PC（程序計數器）：當前執行的字節碼指令地址
2. JVM Stack：該線程的方法調用棧

<br>

**為什麼 PC 是線程私有的？**

* 因為每個線程可能在執行不同的代碼位置。
* 當線程切換時，需要保存和恢復 PC，才能從中斷的地方繼續執行。

<br>

**PC 的值：**

* 如果正在執行 Java 方法，PC 是當前字節碼指令的地址
* 如果正在執行 Native 方法，PC 的值是 undefined（我們不管）

<br>

線程狀態（未來擴展）：

* Java 線程有多種狀態：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED
* MVP 階段我們只實現單線程，後續擴展時會添加狀態管理。

```
 ┌─────────────────────────────────────────────────────────┐
 │                      Thread                             │
 ├─────────────────────────────────────────────────────────┤
 │  pc: int                                                │
 │  ┌──────────────────────────────────────────────────┐  │
 │  │ 程序計數器：指向 method bytecode 中的偏移量        │  │
 │  │ 例如：pc=0 表示執行第一條指令                      │  │
 │  │      pc=3 表示執行第 4 個字節開始的指令            │  │
 │  └──────────────────────────────────────────────────┘  │
 ├─────────────────────────────────────────────────────────┤
 │  stack: *JVMStack                                       │
 │  ┌──────────────────────────────────────────────────┐  │
 │  │          Frame (當前方法)                         │  │
 │  │          Frame (調用者)                           │  │
 │  │          Frame (調用者的調用者)                    │  │
 │  │          ...                                      │  │
 │  └──────────────────────────────────────────────────┘  │
 └─────────────────────────────────────────────────────────┘
```

<br>

到目前為止，runtime 模組還缺少 2 個關鍵單元：

* Heap
* Method Area

__因為 Heap 和 Method Area 需要 ClassLoader，在沒有實現出來之前，都還無法完成整個 runtime。__
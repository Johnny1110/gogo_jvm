# Runtime data areas (WIP)

<br>

---

<br>

## JVM Stack-based Architecture（基於棧的架構）：

```
┌────────────────────────────────────────────────────────────────┐
│                    JVM Runtime Data Areas                       │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐     ┌─────────────────────────────────┐   │
│  │   PC Register   │     │           Heap (堆)              │   │
│  │  (程式計數器)    │     │      所有對象實例都在這裡         │   │
│  │   每線程一個     │     │        所有線程共享              │   │
│  └─────────────────┘     └─────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────┐     ┌─────────────────────────────────┐   │
│  │   JVM Stack     │     │       Method Area (方法區)       │   │
│  │  (虛擬機棧)      │     │     類信息、常量池、方法代碼      │   │
│  │   每線程一個     │     │        所有線程共享              │   │
│  └─────────────────┘     └─────────────────────────────────┘   │
│          │                                                      │
│          ▼                                                      │
│  ┌─────────────────┐                                           │
│  │     Frame       │  ← 每個方法調用創建一個棧幀               │
│  │   ┌─────────┐   │                                           │
│  │   │ LocalVar│   │  ← 局部變量表                             │
│  │   └─────────┘   │                                           │
│  │   ┌─────────┐   │                                           │
│  │   │ OpStack │   │  ← 操作數棧                               │
│  │   └─────────┘   │                                           │
│  └─────────────────┘                                           │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

<br>

### 為什麼選擇 Stack-based 而非 Register-based？

Stack-based（JVM） vs Register-based（Dalvik/CPU）特性比較:

| 特性               | Stack-based（JVM）                     | Register-based（Dalvik / 實體 CPU）        |
|--------------------|-----------------------------------------|---------------------------------------------|
| 指令大小           | 更小（1–3 bytes）                       | 更大（需要指定寄存器）                      |
| 可移植性           | 極佳（不依賴硬體寄存器數量）            | 依賴硬體設計，較不具可移植性                |
| 實作難度           | 較簡單                                   | 較複雜（需管理寄存器配置）                  |
| 執行效率           | 較慢（需要更多 push/pop 記憶體操作）    | 較快（寄存器直接運算）                      |

<br>

Java 的目標是 "Write Once, Run Anywhere"，所以選擇了可移植性更好的 Stack-based 架構。

<br>
<br>

**實作順序：**

```
runtime/
├── thread.go           # 1. 線程（持有 PC 和 Stack）
├── jvm_stack.go        # 2. 虛擬機棧（持有多個 Frame）
├── frame.go            # 3. 棧幀（方法執行的環境）
├── local_vars.go       # 4. 局部變量表
├── operand_stack.go    # 5. 操作數棧
└── slot.go             # 6. 槽位（統一的數據單元） -> 32-bit 基本數據單元
```

<br>
<br>

---

<br>
<br>

## 核心概念

<br>

###  1. Slot (槽位）

**JVM 需要一個統一的方式來存儲不同類型的數據。**

問題：如何用統一的結構存儲 int, float, reference?

解決方案：Slot（32-bit 槽位）

```
  ┌──────────┐                                       
  │   Slot   │  = 32 bits                           
  └──────────┘                                       
       │                                             
       ├── int       → 1 個 slot                       
       ├── float     → 1 個 slot                       
       ├── reference → 1 個 slot（指標）              
       ├── long      → 2 個 slots（64-bit）            
       └── double    → 2 個 slots（64-bit）            
```

<br>

**設計思想：**

* JVM 規範定義局部變量表和操作數棧都是由「槽位」(Slot) 組成的。
* 每個 Slot 可以存放一個 32-bit 的數據。
* 對於 64-bit 的數據（long, double），需要連續的兩個 Slot。

<br>

**為什麼這樣設計？**

* 統一性：不管是 int、float 還是對象引用，都用同樣的結構存儲
* 簡單性：JVM 實現者只需處理一種基本單元
* 對齊性：32-bit 是當時（1995年）最常見的字長

<br>

**為什麼 long 和 double 要佔兩個 slot？**

這是歷史原因：JVM 設計於 1995 年，當時：
* 主流 CPU 是 32-bit
* 32-bit 操作比 64-bit 快
* 記憶體對齊以 32-bit 為單位最有效率

所以 JVM 規範規定：
* long/double 存入時，佔據 slot[n] 和 slot[n+1]
* 讀取時，必須從 slot[n] 開始讀兩個 slot
* slot[n+1] 不能單獨使用（規範要求）

<br>
<br>

###  2. LocalVars (局部變量表）

**設計背景：**

當 JVM 執行一個方法時，需要一個地方存放：

1. 方法參數
2. 方法內部的局部變量

這就是 LocalVars（局部變量表）的作用。

<br>

**重要特性：**

* 表的大小在編譯期就確定了（存在 Code Attribute 的 max_locals 中）
* 通過索引訪問（不是棧，是數組）
* 索引從 0 開始

<br>

**對於物件方法（非 static）：**

* slot[0] 固定存放 this 引用
* slot[1...] 存放參數和局部變量

**對於靜態方法（static）：**

* slot[0...] 直接存放參數和局部變量

<br>

舉例：

```java
public void foo(int a, long b, String c) {
     int d = 0;
}
```

局部變量表佈局：

```
注：long b 佔用了 slot2 和 slot3 兩個
┌───────┬───────┬───────┬───────┬───────┬───────┐
│ slot0 │ slot1 │ slot2 │ slot3 │ slot4 │ slot5 │
│ this  │   a   │ b(低) │  b(高) │   c   │   d   │
└───────┴───────┴───────┴───────┴───────┴───────┘
```

<br>
<br>

###  3. OperandStack (操作數棧）

**設計哲學：**

JVM 是「基於棧」的虛擬機，幾乎所有操作都通過操作數棧完成。

<br>

舉例：計算 `a + b`

* 基於寄存器的方式（x86）：
```
mov eax, a      ; 把 a 載入寄存器 eax
add eax, b      ; eax = eax + b
mov result, eax ; 把結果存回內存
```


* 基於棧的方式（JVM）：
```
iload_0    ; 把局部變量 0（a）壓入棧
iload_1    ; 把局部變量 1（b）壓入棧
iadd       ; 彈出兩個值，相加，把結果壓入棧
istore_2   ; 彈出棧頂，存入局部變量 2（result）
```

<br>

為什麼這樣設計？

1. 指令更簡短（不需要指定寄存器）
2. 實現更簡單（只需 push/pop）
3. 更容易驗證（棧的大小可預測）

操作數棧的大小（maxStack）是編譯期確定的，存在 Code 屬性中。編譯器會分析代碼，計算最大棧深度。